module[
   'qdl:/math/x','mathx'
]body[
   >> This module defines several additional functions for mathematics
   >> These include sec(), sech() etc.

        sec(x)->1/cos(x);
        csc(x)->1/sin(x);
        cot(x)->1/tan(x);
       asec(x)->acos(1/x);
       acsc(x)->asin(1/x);
       acot(x)->atan(1/x);
       sech(x)->1/cosh(x);
       csch(x)->1/sinh(x);
       coth(x)->1/tanh(x);
      asech(x)->acosh(1/x);
      acsch(x)->asinh(1/x);
      acoth(x)->atanh(1/x);


  // Here starts definitions using the full syntax, so we can include some
  // online help.

   define[
       max(a,b)
    ][
       >> max(a,b) - return the maximum of a or b.
       >> E.g. max(-2, 3) returns 3.
       >> E.g. on stems -- corresponding entries are compared
       >>    max([;5],([;5]-2)*3)
       >> [0,1,2,3,6]
       return((a + b + abs(a-b))/2);
    ];

   define[
       min(a,b)
    ][
       >> min(a,b) - return the minimum of a or b.
       >> E.g. min(-2, 3) returns -2.
       >> E.g. on stems -- corresponding entries are compared
       >>    min([;5],([;5]-2)*3)
       >> [-6,-3,0,3,4]
       return((a + b - abs(a-b))/2);
    ];

   define[
      int(x)
    ][
       >>int(x) - return the integer part of a number
       >>
       >> E.g.
       >>    5432/432
       >> 12.574074074074074
       >>    int(5432/432)
       >> 12
       >>
       >> See also: frac(x)
       return(x%1);
    ];

   define[
      frac(x)
    ][
       >>frac(x) - return the fractional part of a number
       >>
       >> E.g.
       >>   5432/432
       >> 12.574074074074074
       >>    frac(5432/432)
       >>0.574074074074074
       >>
       >> See also: int(x)
       return(x - x%1);
    ];

   define[
       hypotenuse(a,b)
    ][
       >> The hypotenuse of a right triangle, given the other two sides.
       >> sqrt(a^2 + b^2);
       return(sqrt(a^2 + b^2));
   ];

   define[
       fibonacci(n)
     ][
       >> Compute the nth Fibonacci number. Note that this uses Binet's  formula
       >> and is very, very fast, even for huge values of 0 <= n.
       >> E.g.
       >>    fibonacci(1000000)
       >> 1.953282128891003E208987
       >>    
       >>    fibonacci([10;20])
       >> [55,89,144,233,377,610,987,1597,2584,4181]
       if[
           reduce(@||, n <0 || floor(n)!=n) // if any are negative or not integers, bail.
         ][
           raise_error('illegal argument. The argument must be a positive integer');
        ];
       root5 := sqrt(5);
           γ := (1+root5)/2;
          γ1 := (1-root5)/2;
          return(floor((γ^n -γ1^n)/root5 + 0.1)); // compensate for rounding errors
     ]; //end fibonacci

   define[
       sqrt(x)
    ][
       >> The (non-negative) square root of the argument
       return(nroot(x, 2));
   ];


   define[
       logn(n,x)
    ][
        >> log(n,x)
        >> The logarithm, base n for x.
        >> Note that both may be stems.
        return(ln(x)/ln(n));
   ];


   define[
        polynomial(coefficients., x)
    ][
        >> polynomial(coefficients., arg) takes a list of coefficients (0th index) is constant and evaluates it.
        >> so polynomial([3,5,7,11], x) == 11*x^3 + 7*x^2 + 5*x + 3
        return(reduce(@+, coefficients.*(x^n(size(coefficients.)))));
   ];

   define[
         poly2(coefficients., x)
    ][
         >> poly2(coefficients., arg) takes a list of coefficients (last index is the constant) and evaluates it.
         >> so poly2([11,7,5,3], x) == 11*x^3 + 7*x^2 + 5*x + 3
         >> This is because some people just find it optically easier.
         return(reduce(@+, list_reverse(coefficients.)*(x^n(size(coefficients.)))));
   ];


      define[
         plot(@f(), arg.)
      ][
        >> A program to generate the plot points a real valued function over an interval.
        >> The result is a list of (x,y) coordinates.
        >> Try it out on
        >> plot(@sin, [|0; pi()/2; 10|])

         y. := f(arg.);
         return(arg.~|y.);
      ];

      define[
         pplot(@x(), @y(), t.)
      ][
        >> A program to generate the parametric plot points of two real valued function over an interval.
        >> The result is a list of (x,y) coordinates.
        >> Try it out on
        >> pplot(@sin,@cos,  [|0; pi()/2; 10|])
         x. := x(t.);
         y. := y(t.);
         return(x.~|y.);
      ];
       define[
          splot(@x(), @y(), @z(), t., s.)
       ][
         >> A program to generate the parametric surface plot points of three real valued functions
         >> over the intervals for t ands.
         >> The result is a list of (x,y,z) coordinates.
         >> E.g.
         >> x(t,s)->sin(t)*cosh(s)
         >> y(t,s)->cos(t)*sinh(s)
         >> z(t,s)->sin(2*t)*cos(3*s)
         >> t. :=⟦-1;1;10⟧
         >> s. :=⟦0;1;10⟧
         >> splot(@x, @y, @z, t., s.)

          x. := x(t., s.);
          y. := y(t., s.);
          z. := z(t., s.);
          // In the next bit, x.~|y. creates the two columns, then we just need
          // to add z. to it.
          return(join(x.~|y., z., 1));
       ];
       /*
         x(t,s)->sin(t)*cosh(s)
         y(t,s)->cos(t)*sinh(s)
         z(t,s)->sin(2*t)*cos(3*s)
         t. :=⟦-1,1,10⟧
         s. :=⟦0,1,10⟧
         splot(@x, @y, @z, t., s.)
       */
]; // end module
