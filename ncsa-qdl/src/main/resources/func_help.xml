<help>
    <entry id="abs">
        <body>
 <![CDATA[abs(arg) - find the absolute value of a number or stem.]]>
        </body>
        <example>
<![CDATA[abs(-2) yields 2.]]>
        </example>
    </entry>
    <!-- NOTE no blank elements -->
    <entry id="date_ms">
        <body>
 <![CDATA[date_ms() - current date in milliseconds
date_ms(arg) - if arg is an integer, return it, if it is a string
               in ISO 8601 format.

See also: date_iso]]>
        </body>
    </entry>
    <entry id="date_iso">
        <body>
 <![CDATA[date_iso() - return the current date as an ISO 8601 formatted string
date_iso(arg) - if arg is an integer, convert it to an ISO string.
                If it is an ISO string, return it.

See also: date_ms]]>
        </body>
    </entry>

    <entry id="decode">
        <body>
 <![CDATA[decode(arg{,type}) - decode an encoded string or stem of strings to string(s).
                  Note that if the arg is encoded binary, you will get
                  gibberish back.

See also: encode]]>
        </body>
    </entry>

    <entry id="encode">
        <body>
<![CDATA[encode(arg{,type}) - encode a string or stem of strings. There are
 various types of encoding allowed.
type  name   notes
 0     v     Variable encode/decode that is QDL safe. Used in boxing, some JSON
 1     url   RFC 3986,  percent encode/decode
 16    hex   RFC 4648, character set is a-e0-9
 32    b32   RFC 4648, character set is A-Z2-7
 64    b64   RFC 4648, character set is  A-Za-z0-9-_

RFC 4648:
   https://datatracker.ietf.org/doc/html/rfc4648

RFC 3986:
  https://datatracker.ietf.org/doc/html/rfc3986

There is never any padding at the end of strings.

See also: decode]]>
        </body>
<example>
<![CDATA[  encode('foobar'); // base 64 default
Zm9vYmFy
  encode('foobar', 32); // base 32
MZXW6YTBOI
   encode('foobar', 16); // base 16 or hex encoding
666f6f626172
   decode('Tr%C4%83m+n%C4%83m', 1); // URL
Trăm năm
   encode('你浣',0); // QDL's encoding
$E4$BD$A0$E6$B5$A3
   decode('$E4$BD$A0$E6$B5$A3',0)
你浣
Note that the last two characters are preserved. This is a famous case that these two are not always encoded
correctly, hence included to show functionality.]]>
</example>
    </entry>

    <entry id="head">
        <body>
 <![CDATA[head(target, delim{,is_regex}) - Return up to delim in the
                 target. Both of the first arguments
                 may be conformable stems. The result is always conformable to
                 target.
                 is_regex - if true splits using the second as a regex.
See also: tail]]>
        </body>
        <example>
<![CDATA[   head(['bob@foo', 'todd@foo', 'rolf!baz'], '@')
[bob,todd,]

Note that there is no match for the last element, so an empty string is
returned.
Equivalent to tokenize(target, delim, is_regex).0]]>
                </example>

    </entry>
    <entry id="tail">
        <body>
 <![CDATA[tail(target, delim{,is_regex}) - Return from after the last
                 delim in the target to the end of the string.
                 Both of the first arguments may be conformable stems.
                 The result is always conformable to target.
                 is_regex - if true treats the second argument as
                 a regular expression
See also: head]]>
        </body>
        <example>
<![CDATA[   tail(['bob@psu.edu', 'todd@bsu.edi', 'rolf!baz'], '@')
[psu.edu,bsu.edi,]

Note that there is no match for the last element, so an empty string is
returned.

      tail('a d, m,\ti.n','\\s+', true);    // uses whitespace
i.n

This is equivalent to returning tokenize(a,b,is_regex).(-1);]]>
                </example>

    </entry>


    <entry id="check_syntax">
        <body>
 <![CDATA[check_syntax(string) - This will take the (possibly very long) string and run
                       it through the parser checking for syntax errors. Note
                       that this does not run anything! Its use is to help
                       you track down errors like missing semi-colons, illegal
                       characters and other statements. It returns either an
                       empty string (no issues found) or an error message
                       containing something like 'syntax error: line 1:4'.
                       This means that the first line of input (lines are
                       counted starting at 1) had an error at position 4
                       (characters on the line are counted from zero).
E.g.
   check_syntax(file_read('/path/to/file/x.qdl'))
syntax error:line 11:27 mismatched input '=' expecting {'^', '>=', '<=', ...

Meaning that on line 11, position 27 there was an error in the file.

Note that if you are running this on stand-alone scripts (that start with
a shebang directive of #!) the shebang will cause this to fail. Simply
comment out the first line to use the syntax check on it or otherwise
prevent it from being checked. The shebang is used by the operating system
and is not part of QDL.
See also: execute]]>
        </body>
    </entry>
    <entry id="hash">
        <body>
 <![CDATA[hash(arg) - calculates the SHA-1 digest of a string or stem of strings.
            The output is a hexadecimal string. Note that this has nothing to
            do with converting to or from hex strings.]]>
        </body>
    </entry>
    <entry id="mod">
        <body>
 <![CDATA[mod(a,b) - compute the modulus, i.e., the remainder after long division, of two
           integers. The arguments are either scalar or stems.]]>
        </body>
    </entry>
    <entry id="numeric_digits">
        <body>
 <![CDATA[numeric_digits() - display the current precision
numeric_digits(arg) - set the precision to the value of arg, which is a
                      positive integer.
                      The result displayed is the old precision.
Note: Precision refers to the total number of digits that are considered
      accurate. So if the precision is 5, the number 4321.12345 is actually
      only accurate to 4321.1 and anything after that is an artifact of
      approximation. QDL will show values as accurately as possible,
      so if the value were 1.00000009 then QDL would display 1 as the
      value, since up to precision, they are the same.
      See the reference manual for a more information.]]>
        </body>
<example>
<![CDATA[In this example. precision is set high and a large number has its
square root approximated, then squared. The result is the original number
plus an extended artifact of the approximation. The size of the result is
50 digits (lead integer then 49 places to the right of the decimal point.)

  numeric_digits(50)
15
  sqrt(945602795792794567)^2
9.4560279579279456700000000000000000000000000000087E17]]>
</example>
    </entry>
    <entry id="random">
        <body>
 <![CDATA[ random() - return a random number
random(n) - return n (an integer) random numbers as a stem list.]]>
        </body>
    </entry>
    <entry id="random_string">
        <body>
 <![CDATA[random_string() - return a random string of 16 bytes, base 64 encoded.
   random_string(n) - return a random string of n bytes, base 64 encoded
random_string(n, m) - return a list containing m entries with n bytes each,
                      base 64 encoded
See also: encode, decode]]>
        </body>
    </entry>

    <entry id="box">
        <body>
 <![CDATA[box(arg0, arg1, ...) - take any collection of variables and turn them into a
                       single stem, their names becoming keys. They are removed
                       from the symbol table. There must be at least one
                       argument and the result is a boolean true if it
                       succeeded and false otherwise (so you can test
                       programatically if it worked).
See also: unbox]]>
        </body>
    </entry>
    <entry id="exclude_keys">
        <body>
<![CDATA[exclude_keys(target., list.) - remove the list. of keys (and their values) from
                               target.

Note: The result will be a subset of target. that contains none of the keys
      listed in the list. argument.]]>
        </body>
<example>
<![CDATA[ exclude_keys([2,4,6,8],[1,2])
{0:2,3:8}]]>
</example>
    </entry>
    <entry id="from_json">
        <body>
 <![CDATA[from_json(arg | arg.) - takes the argument which is a string  or stem of string
                          representation(s) of JSON and turns it into a stem or stem of stems.
from_json(arg | arg., convert) - as per single argument case, but allows a flag (true
                          or false) if vencode is to be applied to each key.
                          The default is false.

Note that i the case of stems,  this will only convert strings, so non-strings will be skipped
and not returned.
See also: vencode, to_json]]>
        </body>
<example>
    <![CDATA[Here is an example to read an encoded JWT (JSON Web Token)
from the  clipboard, decode it and turn it into a stem. A JWT is of the
form X.Y.Z where X, Y and Z are base 64 encoded. Z (if present) is a
binary signature, so cannot be read.

    jwt()->from_json(decode(tokenize(cb_read(), '.')));
/* Typical JWT. Copy it to the clipboard:

eyJraWQiOiJCRUZGRjU4NzZEMTAiLCJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.
eyJ3bGNnLnZlciI6IjEuMCIsImF1ZCI6Imh0dHBzOi8vd2xjZy5jZXJuLmNoL
2p3dC92MS9hbnkiLCJzdWIiOiJqZ2F5bm9yIiwibmJmIjoxNjU2MDIwMjMxLCJz
Y29wZSI6Ii9ob21lL2plZmYifQ.
bYPQkk7VDPVF4EYM4KpPRtzdIEyaPraEc7Tg
-xr6FBXzg5gDUdEWyscAvBbGm77Pj0Hn0OJrKZ1lux8SgB_DkBo

Do note that base 64 decode ignores any embedded blanks and linefeeds,
as per the spec.
*/
  jwt()
[
  {
  kid:BEFFF5876D10,
  typ:JWT,
  alg:RS256
 },
  {
  wlcg.ver:1.0,
  aud:https://wlcg.cern.ch/jwt/v1/any,
  sub:jgaynor,
  nbf:1656020231,
  scope:/home/jeff
 }
Note that the last field of Z here is not converted since it binary is not
valid JSON and therefore and cannot be turned into a stem.]]]>
</example>
    </entry>
    <entry id="list_keys">
        <body>
 <![CDATA[list_keys(arg.) - returns a list of the keys in the argument.
list_keys(arg., boolean) - returns a list of the keys in the argument.
                           which is a boolean that when true will
                           return only those keys whose values are
                           scalars. if false, stem keys are returned.
list_keys(arg., var_type)- returns a list of the keys in the argument.
                           for the given type (which is an integer).

Remember that strings are scalars.
See also: keys(), var_type(), constants('var_type')]]>
        </body>
    </entry>
    <entry id="has_keys">
        <body>
 <![CDATA[has_keys(target., key_list.) - returns a boolean list that is the same size as
                               key_list. and has a true or false if that entry
                               is a key in target.
See also: list_keys]]>
        </body>
    </entry>
    <entry id="include_keys">
        <body>
 <![CDATA[include_keys(target., key_list.) - returns a stem that is the subset of target,
                                   including only keys found in key_list.
See also: exclude_keys]]>
        </body>
        <example>
<![CDATA[  include_keys([2,4,6,8],[1,2])
{1:4,2:6}]]>
                </example>

    </entry>
    <entry id="n">
        <body>
 <![CDATA[n(n0,n1,...{, values.}) - make a stem list whose values are 0,..., n-1
n(dim.{,value | values.}) - make a list with dimension dim.
Note: This is extremely useful in certain looping constructs.
See also: shuffle(n) which also creates the same list of integers, but in
          random order. ]]>
        </body>
        <example>
<![CDATA[  n([3,4],[;12])
[
  [0,1,2,3],
  [4,5,6,7],
  [8,9,10,11]
 ]

This has dimension [3,4]. You could also enter this as
    n(3,4,[;12])]]>
                </example>

    </entry>

    <entry id="identity">
        <body>
 <![CDATA[identity(x) - return x unchanged. This is useful for instance if you
              need a function to express a value rather than just the
              value itself.
A nickname for this function is i(). ]]>
        </body>
    </entry>
    <entry id="input_form">
        <body>
 <![CDATA[input_form(module) - The argument is a string with the name of the module
                        or one of its aliases.
 input_form(variable) - The argument is a variable (not a string)
input_form(f, arg_ct) - The arguments are a function (not a string) and the
                        number of arguments.

Note that as an artifact of parsing, whitespace may be different. The result, however
if interpreted,  will return the original argument.
See also: execute();]]>
        </body>
        <example>
<![CDATA[  f(x)->x^2
  input_form(f, 1)
f(x)
->
x^2;

Note that the whitespace is different.]]>
                </example>

    </entry>
    <entry id="has_value">
        <body>
 <![CDATA[has_value(left_arg, right_arg) - returns a left conformable of booleans
         (so a scalar left arg returns a scalar, but a stem returns a stem).
         This checks the the value of the left_arg is in the
         right_arg. Note that unlike many other stem functions, the keys are
         ignored. The resulting key set will always be identical
         to the left_arg.
See also: mask, ∈]]>
        </body>
        <example>
<![CDATA[  has_value([;3], {'a':2,'b':null});
[false,false,true]
// since only the value of 2 in the left_arg is in the right_arg]]>
                </example>
    </entry>
    <entry id="is_list">
        <body>
 <![CDATA[is_list(stem.) - returns a true if the stem. is a list, i.e., the only keys are
                 integers.]]>
        </body>
    </entry>
    <entry id="keys">
        <body>
 <![CDATA[keys(arg.) - returns a stem of all the keys in arg. Every key is returned and
             the value is just the key itself
keys(arg., boolean) - returns a stem of the keys in the argument.
                      If the boolean is true will return only those keys whose
                      values are scalars. if false, stem keys are returned.
keys(arg., var_type)- returns a stem of the keys in the argument.
                      for the given type (which is an integer).
This is extremely useful
in conjunction with the rename_keys() call.
If you supply and integer for the variable type, only
Note: There is no canonical ordering of keys, so these are effectively random.
See also: list_keys(), indices, rename_keys(), var_type(), constants('var_type')]]>
        </body>
        <example>
<![CDATA[   constants().var_type; // list variable types
{boolean:1, set:10, string:3, null:0, integer:2, decimal:5, stem:4, undefined:-1}
   arg. := [2,-3/7,'abc', false, 'rst', pi()/11]
   keys(arg., 3); // get keys of strings only
 {2:2, 4:4}
   keys(arg., 5); // get decimals only
{1:1, 5:5}
   // Let's compare this with indices
  keys(arg.)
[0,1,2,3,4,5]
  // since this returns a stem of integer values keyed by integer, it is a list.
  indices(arg.)
[[0],[1],[2],[3],[4],[5]]
  // Each of these is a list and is the complete path inside the stem to the element.
  arg.keys(arg.).0 == 2 == arg.indices(arg.).0
true]]>
                </example>
    </entry>

    <entry id="copy">
        <body>
 <![CDATA[copy(source., start_index, length, target., target_index) -
               copy one list into another, overwriting old elements.

     source. = the stem that is the source of the copy.
 start_index = the index in source. where the copy starts
      length = how many elements to copy from source.
     target. = the target stem of the copy
target_index = the index  target. that will receive the copy. Note that
               any elements already in these locations will be replaced. If you
               need to insert elements, consider using the insert_at
               command.
See also: insert_at]]>
        </body>
        <example>
<![CDATA[   copy([1,2,3,4,5,6],1,2,[10,11,12,13,14,15], 3)
[10,11,12,2,3,4]]]>
                </example>

    </entry>
    <entry id="insert_at">
        <body>
 <![CDATA[insert_at(source., start_index, length, target., target_index) -
               insert one list in another, moving the old elements.

     source. = the stem that is the source of the copy.
 start_index = the index in source. where the copy starts
      length = how many elements in source. to copy
     target. = the target stem of the copy
target_index = the index in target. that will receive the copy. Note that
               any elements already in these locations will be moved. If you
               intend to replace a section of this list, consider using the
               copy command.
See also: copy]]>
        </body>
        <example>
<![CDATA[   insert_at([1,2,3,4,5,6],1,2,[10,11,12,13,14,15], 3)
[10,11,12,2,3,13,14,15]]]>
                </example>
    </entry>
    <entry id="remap">
        <body>
 <![CDATA[Take the elements in arg. and create a new stem. There are two cases:

remap(source_list., index_list.) - returns the elements of source_list.
          as specified in index_list. The result is always a simple list.

The contract runs as follows. If
   index_list. := {k0:v0, k1:v1, ..., kn:vn}
then the result, r., satisfies
  r.kj := source_list.vj;

E.g. Show basic contract
    r. := remap(3*[;10], 2*[;5]+1)
    r.
[3,9,15,21,27]

Note that
  source_list. := [0,3,6,9,12,15,18,21,24,27]
   index_list. == [1,3,5,7,9]
                   0 1 2 3 4 <-- indices in the list
  r.0 := source_list.1
  r.1 := source_list.3
  r.2 := source_list.5
  r.3 := source_list.7
  r.4 := source_list.9

Most general case
remap(source_list., old_indices., new_indices) - returns the elements of source_list.
          as specified by (assuming out. is the returned result)

          out.new_indices.i := source_list.old_indices.i

This permits a very general remapping of any stem to any other stem,
where new_indices. determines the resulting shape. Remember that
*_indices. are lists in 1 to 1 correspondence.

E.g. Using stem indices on higher rank arguments
Remember that for a stem a.,
   a.[p,q] == a.p.q
This lets you select a subset like so:
   a. := n(3,4,n(12))
   r. := remap(a., [[0,1],[1,1],[2,3]])
   r.
[1,5,11]

And
    r.0 := a.[0,1]
    r.1 := a.[1,1]
    r.2 := a.[2,3]

Note: If you need to re-roll one array (e.g.) into another, the right way to
do it is using the n function:
   n(2,2, remap(a., [[0,1],[1,1],[2,3],[2,0]]))
[[1,5],[11,8]]

It is vastly easier to do it this way than have some extremely complex remapping
scheme for higher rank stems. You get back a (more or less) linear structure
you can then recast as needed.

See also: transpose, n (function), rename_keys]]>
        </body>
        <example>
<![CDATA[E.g: Turn an array into a flat list
   a. := [;5]
   a.'foo' := 'bar'
  remap(a., indices(a.))
[bar,0,1,2,3,4,5,6,7,8,9,10,11]

E.g. Remapping the result to a non-list stem
   r. := remap(3*[;15], {'foo':3,'bar':5,'baz':7})
   r.
{bar:15, foo:9, baz:21}

 Note that
   r.'foo' := source_list.3
   r.'bar' := source_list.5
   r.'baz' := source_list.7

Yes, you can use arbitrary indices to so
   remap(a., {'foo':[0,1],'bar':[1,1], 'baz':[2,3]})
{bar:5, foo:1, baz:11}

is fine, though, of course, in the general case of stems, there is no
canonical ordering of keys...

Example: General case, getting the transpose of a stem.
In linear algebra, a matrix A[i,j] is the transpose of B[i,j] if
  A[i,j] = B[j,i]
I.e., the term on the left has the indices swapped.
In QDL, this is done by reversing each of the indices
So if our stem is
      a. := n(3,5,n(15))
      say(a., true)
      [
        [0,1,2,3,4],
        [5,6,7,8,9],
        [10,11,12,13,14]
       ]
Then we need to reverse all the old indices (that means indices for the last
axis), and we reverse each of them for the new indices.
  old. := indices(a.,-1)
  new. := for_each(@reverse,  old.)
So to get the transpose,
   b. := remap(a., old., new.)
   say(b., true)
[
  [0,5,10],
  [1,6,11],
  [2,7,12],
  [3,8,13],
  [4,9,14]
 ]

 Note that this works on any  higher order stems as well.]]>
                </example>

    </entry>
    <entry id="pick">
       <body>
  <![CDATA[Function to pick elements from an aggregate argument.
pick(@f, arg) - picks elements from arg based on the boolean @f
          function. If arg is a stem or set, so is the result. If arg
          is a scalar, so is the result. Note that for a scalar, if the
          arg fails the test,a null will be returned.
          The number of allowed arguments for @f is 1 or 2.

          If f is monadic  the value supplied is the value itself.
          If f is dyadic  the values are (key, value).

Note that any indices are returned as well.
  ]]>
       </body>
       <example>
   <![CDATA[  pick((v)->v<3, {-2,0,4,5}); // pick elements in a set whose value < 3
   {0,-2}

       pick((key,value)->mod(key,2)==0, [-4;5]); // get the elements with even indices
   {0:-4, 2:-2, 4:0, 6:2, 8:4}

       // example where key+value are divisible by 3:
       pick((key,value)->mod(key+value,3)==0, [-4;5]);
   {2:-2, 5:1, 8:4}
       // How to select all the elements of a stem, x., that contain the substring 'my_string'
       // Note that index_of always returns a list with at least one element. -1 means 'my_string'
       // was not found.
       pick((k,v)->-1 < index_of(v, 'my_string').0, x.)]]>
        </example>
    </entry>

    <entry id="sublist">
        <body>
 <![CDATA[Function to extract a sublist from a list or set.

sublist(set, count) - get count elements from a list. Since sets have no
          order, no promises are made on which elements are returned.

=> Note that for the remaining calls, the arg is a list and the result is
=> *always* a rank 1 stem and this operates only on the zeroth axis.


sublist(source_list., start_index) -
          return a sublist of the source_list starting at the given index.
sublist(source_list., start_index, n) -
          return a sublist of the source_list starting at the given index,
          but only return the next n elements.

This gives yet another way to access list elements.

Note: * If n is omitted, then the rest of the list is returned from
        the start index on.
      * If size(source_list.)<n, then the rest of the list is returned
        from the start index on.
      * The source is not altered and the resulting list has 0 as
        its first index.
      * If the list is sparse, then you get back up to the next n
        elements.

Q: How do I get back a sublist for a specific set of indices?
A: Use remap. sublist is specific to lists and sets.
   E.g.
      remap(a., [3,7,11]) returns exactly the list
   [a.3, a.7, a.11]

See also: n(), remap, pick]]>
        </body>
        <example>
<![CDATA[  sublist({'a', 2,1,3/7,'b'}, 2); grab 2 elements from the set
{a,1}

   sublist([10;20],4); // get rest of list from index 4 on
[14,15,16,17,18,19]

   sublist([10;20],-4); // get tail of the list from index -4 on
[16,17,18,19]

   sublist([10;20],4,2); // start at index 4, give next 2 elements
[14,15]

   sublist('a',1,3); // sublist of a scalar is just the element in a list
[a]
    b. := [;15];remove(b.4);remove(b.7);remove(b.10);remove(b.11); // sparse list
    b.
{0:0, 1:1, 2:2, 3:3, 5:5, 6:6, 8:8, 9:9, 12:12, 13:13, 14:14}
   sublist(b., 1000); // no such element
[]
    sublist(b., 8, 3)
[8,9,12]
    // Starts at index 8, returns the next 3 elements in the list. Note there is
    // a gap from 9 to 12 in the list.

      sublist(b., -5, 2)
[9,12]
      // since the list has a last element of 14, 14 + (-5) = 9 is where the
      // sublist starts. The next two actual elements in the list are returned.]]>
                </example>

    </entry>
    <entry id="mask">
        <body>
 <![CDATA[mask(target., bit_mask.) - returns a subset of target. corresponding to each
                           true value in the mask.
Note: This operates generally on stems. Many operations return boolean stems
      which can be used with this function.

If you need something similar for sets (which have no concept of addressing
elements) use pick(@f, set).

See also: pick, sublist]]>
        </body>
        <example>
<![CDATA[Let's make a random list of numbers and get the negative then positive ones.
Do note that the indices are not automatically re-ordered (since mask
applies to generic stems and that would be bad).

  r. := mod(random(5),97)
  r.
[-93,77,56,-46,67]
  mask(r., r. < 0)
{0:-93,3:-46}

  ~mask(r., r. > 0); // reorder the list with ~
[77,56,67]]]>
                </example>

    </entry>
    <entry id="rename_keys">
        <body>
 <![CDATA[rename_keys(target., new_names.{,overwrite}) - rename the keys in target. using new_names.
     new_names. is stem of the form
        {old0:new0, old1:new1,...}
            where old* are the current names of the keys in target.
            and new* are the new names
            target.old_j is replaces with target.new_j but unspecified entries
            are not changed.
            Modifies target. AND returns the modified target.
      overwrite (optional) - boolean that will replace existing values on the rename.
                 Default is false.
This function has relatively simple syntax and is a common idiom.

See also: remap]]>
        </body>
<example>
<![CDATA[   //Keys have a common prefix of 'x_' Remove the prefix.
    a. := {'x_x':'A','x_y':'B'};
    rename_keys(a., keys(a.)-'x_');
{x:A,y:B}

Note that a. has been altered.
Remap can do something similar, but the arguments are different since
 they are
lists. To repeat the above example using remap:

    b. := {'x_x':'A','x_y':'B'};
    remap(b.,list_keys(b.), list_keys(b.)-'x_')

Note b. would not be changed.

E.g.
     c.'x':='X'; c.x_y := 'Y';
     ndx. := {'x_y':'x'};

If you issue

     rename_keys(c., ndx.);

it will fail because c.x would be over written. You may force it with
the given flag

     rename_keys(c., ndx., true);
{x:Y}]]>
</example>
    </entry>

    <entry id="set_default">
        <body>
 <![CDATA[set_default(arg., scalar | stem.) - sets the default value for arg. to the value
                             of scalar or stem.
Note: The default value is not returned in any key operations, so setting the
      default for a new stem and using the keys() function on it returns an
      empty list, for instance.
Returns the old default value (if any) or null.

]]>
        </body>
<example>
<![CDATA[   The following are equivalent
  b. := {*:[2,4]};

  set_default(c., [2,4])
null

The first creates the variable b., the second creates the variable c. and
tells you there was no previous default set.]]>
</example>
    </entry>
    <entry id="size">
        <body>
 <![CDATA[size(arg) -  return the size of the argument.

arg is a stem - return the number of elements in the stem
arg is a string - return the number of characters in the string, i.e., its
                length
args is a scalar - zero, since scalars (such as integers) have no size.]]>
        </body>
    </entry>
    <entry id="to_json">
        <body>
 <![CDATA[                 to_json(stem.) - convert the stem to a JSON string.
        to_json(stem., convert) - if convert is true, vencode all keys in the
                                  JSON for the stem
to_json(stem., convert, indent) - (requires convert), indent is an integer
                                  giving the number ofspaces to indent the
                                  JSON string
The default for convert is false.

See also: from_json]]>
        </body>
    </entry>
    <entry id="unbox">
        <body>
 <![CDATA[unbox(arg.{, safeModeOn}) - takes the argument (a stem) and turns each element
                             by (non-integer) key into a variable.
                             safeModeOn (default is true) will NOT overwrite
                             any variables in the current workspace, AND it will
                             vencode any keys needed. Turning
                             safeModeOn to false will fail if a variable exists or
                             if unboxing would result in an illegal varaible name.
E.g.
   a :='f(x)';
   x.a := 2; // perfectly legal
   x.
{f(x):2}
   unbox(x.)
   )vars
f$28x$29

because 'f(x)' cannot be a legal variable name so it was vencoded.
See also: box, vencode, vdecode]]>
        </body>
    </entry>

    <entry id="to_uri">
        <body>
 <![CDATA[to_uri(string) - Takes a string that is a valid URI and returns a stem variable
                 with all the parts (scheme, query, etc.) put into entries.
                 This is RFC 3986 compliant.
See also: constants() for the field names, from_uri.]]>
        </body>
    </entry>

    <entry id="from_uri">
        <body>
 <![CDATA[from_uri(stem.) - Turn a stem into a uri. Typically if you have a uri in the
                  variable x, then
   x == from_uri(to_uri(x))
should be true.

See also: constants() for the field names, to_uri.]]>
        </body>
    </entry>
    <entry id="unique">
        <body>
 <![CDATA[unique(list.) - Take a stem and return a list of the unique elements.

This may be used on any stem and it will recurse the entire stem.
There is never any implied order.

See also: values]]>
        </body>
        <example>
<![CDATA[  unique(['a',2,4,true]~[[['a','b',0,3,true]]])
[0,a,2,b,3,4,true]]]>
                </example>

    </entry>
    <entry id="halt">
        <body>
 <![CDATA[halt([message]]) - This will halt the system on this line and update the
                     workspace state indicator, passing along the message.
                     Note that this is properly a debugging tool.

This is disabled in server mode.]]>
        </body>
    </entry>
    <entry id="union">
        <body>
 <![CDATA[union(arg0., arg1., ...) - takes the union of all stems, returning a single
                           stem all of whose keys-values are taken form the
                           arguments. Note that the stems are processed in
                           order and values may be over-written.

Note that this is for stems. For sets, use \/ (or ∪).

See also: sets, /\ or ∩.]]>
        </body>
    </entry>
    <entry id="dir">
        <body>
 <![CDATA[dir(arg) - list the names of the files in a given location. Note that this
           is VFS aware.
Note: Directory names will have a / appended to them. Also, if the directory is
empty, the result will be an empty list. If the arg is not a directory, then
the result is null.]]>
        </body>
    </entry>
    <entry id="mkdir">
        <body>
 <![CDATA[mkdir(arg) - make a directory. Note that if there are path components that do
             not exist, they will be created. This returns true if it worked.
Note: One major reason for this to fail is that, e.g., a virtual file system
      is mounted in read only mode.]]>
        </body>
    </entry>
    <entry id="rmdir">
        <body>
 <![CDATA[rmdir(path) - remove the last component of this path (which must be a
              directory).
Note that the directory must be empty first.

See also: rm - remove a single file]]>
        </body>
    </entry>
    <entry id="rm">
        <body>
 <![CDATA[rm(file_name) - removes the given file.]]>
        </body>
    </entry>

    <entry id="say">
        <body>
 <![CDATA[say(arg) - print anything.
say(arg, pretty_print) - print anything, but make the format more vertical if
                         its a stem.
Note: say returns the value of its argument so this can be used in statements
for debugging too.

See also: print]]>
        </body>
    </entry>
    <entry id="print">
        <body>
 <![CDATA[print - this is a synonym for the say function, so read the help for that.]]>
        </body>
    </entry>
    <entry id="file_read">
        <body>
 <![CDATA[file_read(file_name) - read a file in. The result is a single string of the
                       file contents
file_read(file_name, type) - type is an integer that determines the result:
-1 = as string (default)
 0 = binary. This reads the file and hands back a single base 64 encoded
     string of the contents.
 1 = stem. A stem list whose entries are each line in the file.
 2 = ini(tialization) file format. See the entry under 'ini' in help

See also: decode_64, ini]]>
        </body>
    </entry>
    <entry id="scan">
        <body>
 <![CDATA[scan([prompt]) - get user input. The prompt is optional, but will be printed.
                 Input from the console blocks until
                 the user hits enter.]]>
        </body>
        <example>
<![CDATA[  scan('say something>'); // The user types in 'The rain in Spain' at the prompt
say something>The rain in Spain...
The rain in Spain...]]>
                </example>

    </entry>
    <entry id="vfs_mount">
        <body>
 <![CDATA[vfs_mount(cfg.) - mount a virtual file system.
Note: The cfg. contains the configuration and is not trivial to describe.
      Read the reference manual for the details.

You can mount VFS's when starting the workspace. See the configuration
reference manual for details.

See also: vfs_unmount]]>
        </body>
<example>
<![CDATA[E.g. mounting an in-memory VFS

   cfg.type :='memory';
   cfg.scheme := 'ram-disk';
   cfg.mount_point := '/vfs/cache';
   cfg.access := 'rw';
   vfs_mount(cfg.);
true

Now you can issue commands like
   file_write('ram-disk:#/vfs/cache/readme.txt', readme.);

This will write the value of the variable readme. to the
file readme.txt in the VFS.]]>
</example>

    </entry>
    <entry id="vfs_unmount">
        <body>
 <![CDATA[vfs_unmount(mount_point) - unmount the file system at the given mount_point

This does nothing to the mounted file system, it simply makes it inaccessible
in the current environment. If the mount_point is invalid, an error is raised.
Otherwise, a true is returned.

See also: vfs_mount]]>
        </body>
<example>
<![CDATA[E.g.
   vfs_unmount('vfs#/mysql/')
true

The file system mounted at vfs#/mysql/ is now no longer accessible and any
operations against it will fail henceforth, e.g.
   dir('vfs#/mysql/')
null

]]>
</example>
    </entry>


    <entry id="file_write">
        <body>
 <![CDATA[file_write(file_name, contents) = write the contents to the given file.
                                  contents can be a string or a list of strings
file_write(file_name, contents, is_base_64) = same, but if is_base_64 is true,
                                  then the contents are decoded to binary
                                  before writing. The default is that this
                                  flag is false.

See also: file_read, decode, encode]]>
        </body>
    </entry>
    <entry id="starts_with">
        <body>
 <![CDATA[starts_with(x., y.) - returns a left conformable list that has the
                           indices of the right argument.  If there
                           is no such element, an index of -1 is returned.

Is there and ends_with command? No. Use =~ instead, e.g. to check if a string
in the variable x ends in '.xml'
  '.*xml' =~ x

If you need to find if a string begins with a set of characters, use index_of
instead and test the location:
   index_of('abc','a') == 0
true

See also: mask, =~, index_of]]>
        </body>
<example>
<![CDATA[E.g.
  starts_with(['a','qrs','pqr'],['a','p','s','t'])
[0,-1,1]
How to read this: left element 0 starts with right element 0
                   "     "     1  does not start with any
                   "     "     2 starts with right element 1

To get a list of these, use mask, e.g.
     mask(['a','qrs','pqr'], -1 <starts_with(
                                 ['a','qrs','pqr'],
                                 ['a','p','s','t']));
{0=a, 2=pqr}

This returns a list (always) so that it works with mask and other functions.]]>
</example>

    </entry>

    <entry id="shuffle">
        <body>
 <![CDATA[shuffle(n) - n is a positive integer, shuffle the first n integers randomly
shuffle(target., keys.) - shuffle (i.e., permute) the keys in the target.
                          according to keys.
                          Argument keys. must have the same keys as the target.
                          AND the values of keys. are (as a set) the same as
                          the keys. in the target.
See also: indices, rename_keys, which lets you rename some of the keys in a
          stem.]]>
        </body>
        <example>
<![CDATA[E.g.
   shuffle(7)
[5,0,4,6,1,2,3]
Note that if you run this example, the result will be very probably be
different since the result is random.

E.g.
    shuffle(2+3*[;4]], [2,1,3,0])
[8,5,11,2]

In this case, the left argument is [2,5,8,11] and the right argument
has 0->2, 1->1, 2->3, 3->0. This works generally with stems too.]]>
                </example>

    </entry>
    <entry id="execute">
        <body>
 <![CDATA[execute(arg) - take the argument which is a string and execute it as if it
               were typed in.]]>
        </body>
        <example>
<![CDATA[   execute('2+2');
4]]>
                </example>

    </entry>
    <entry id="script_args">
        <body>
 <![CDATA[  script_args() - return out the number of arguments to this script
script_args(-1) - returns the script arguments as a list.
 script_args(n) - return the nth argument (first argument is 0).

Note: This is specific to scripts and bridges communication between QDL
      and the external OS, hence it is a wee bit odd.
      If the script is called in QDL, the
      arguments may be any QDL data type. If this is called from the command
      line by another process, the arguments will all be strings (even if they
      are passed in as, e.g. numbers). This is why there is a specific argument
      (== -1) to get the result as a stem. If the script is called by QDL, then
      the argument types are preserved.

See also: script_load, script_run]]>
        </body>
    </entry>
    <entry id="script_load">
        <body>
 <![CDATA[script_load(file_name) - load the script and run it.
script_load(file_name, arg0, arg1, ...) - load the script, passing in the given
                         arguments
Note: Loading a script means to run it in the current session.
See Also: script_run, script_args]]>
        </body>
    </entry>
    <entry id="script_run">
        <body>
 <![CDATA[script_run(file_name) - run the script
script_run(file_name, arg0, arg1,...) - run the script, passing in the given
                        arguments
Note: Running a script means that a new clean environment is created and the
      script is run there. Output and input, however, are done in the current
      console.

See Also: script_load, script_run, scan, say, print]]>
        </body>
    </entry>

    <entry id="info">
        <body>
 <![CDATA[info() -- a stem of all current information about the session
          such as load paths, memory and such.
info(key) - key is a string. This returns the single value for the given key.
E.g. info('user.home_dir') prints out the current user's home directory.

See also: constants()]]>
        </body>
    </entry>
    <entry id="constants">
        <body>
 <![CDATA[constants() - all constants associated with the system
constants(key) - key is a string. This returns the value of a specific key.
E.g.
     constants('file_type.binary')
returns the integer that can be used in the file_read function.

See also: info()]]>
        </body>
    </entry>
    <entry id="is_defined">
        <body>
 <![CDATA[is_defined(var) - a boolean-valued function that tells you if a given variable
                  has been named.
Note: the argument is not a string, it is the actual variable.]]>
        </body>
    </entry>
    <entry id="is_function">
        <body>
 <![CDATA[is_function(name) - checks if the value of name (it is a string) is defined.
is_function(name, arg_count) checks if a function given in name with the number
                    of arguments is defined.]]>
        </body>
    </entry>
    <entry id="os_env">
        <body>
 <![CDATA[os_env() - return a stem of all operating system environment values currently
           known by the system
os_env(arg0, arg1, ...) = given a list of names (as strings) return a stem with
                          each name as a key. If a property
                          is not found, that entry is omitted.
E.g: os_env('PATH') will give you the values of the PATH variable on most
     systems
Note 1: If you set environment variables in a shell script that invokes QDL,
        you may recover them using this call.
Note 2: This is always empty in server mode! Scripts have no access to the
        underlying system.]]>
        </body>
    </entry>
    <entry id="remove">
        <body>
 <![CDATA[remove(var) - remove a variable and its value from the symbol table.
Note: This expunges it from the session and any future attempts to access it
      will result in errors until it is set again.

See also: is_defined]]>
        </body>
    </entry>
    <entry id="script_path">
        <body>
 <![CDATA[script_path() - returns the list of paths used to resolve scripts
script_path(arg) - sets the script path. Either this is a string each of whose
                   paths are separated with a colon, e.g. 'path0:path1' or it
                   is a stem of paths.
Note: When invoking a script with an absolute path, that is run. If the path
      is relative, then the script paths are used to resolve it. Note that if
      relative path has a scheme for a VFS, then this restricts resolution to
      those paths. If the path is unqualified, every path is checked.

See also: script_load, script_run]]>
        </body>
    </entry>
    <entry id="module_path">
        <body>
 <![CDATA[   module_path() - returns the list of paths used to resolve loading modules
module_path(arg) - sets the module path. Either this is a string each of whose
                   paths are separated with a colon, e.g. 'path0:path1' or it
                   is a stem of paths.
Note: When loading a module with an absolute path, that is run. If the path is
      relative, then the module paths are used to resolve it. Note that if
      relative path has a scheme for a VFS, then this restricts resolution to
      those paths. If the path is unqualified, every path is checked.

See also: module_load]]>
        </body>
    </entry>
    <entry id="to_number">
        <body>
 <![CDATA[to_number(arg) - convert a string or stem of strings to numbers. Each number
                 must be a valid string representation.]]>
        </body>
    </entry>
    <entry id="to_string">
        <body>
 <![CDATA[to_string(arg) - arg is anything and the result is a string representation
                 of it.
to_string(arg, is_pretty_print) - attempt to put the result in to a nicer
                 format.
Note: The print or say function effectively calls this and spits out the
      result to the console.]]>
        </body>
    </entry>
    <entry id="to_boolean">
        <body>
 <![CDATA[to_boolean(arg) - arg is anything and the result is a boolean representation.
                  Note that this means
                  strings - true is only returned if the value is 'true'
                  integers - true is only returned if the value is 1
                  decimals - true is only returned if the integer part is 1
                  booleans - returned unchanged.
                  stems - applied to each element.]]>
        </body>
    </entry>
    <entry id="var_type">
        <body>
 <![CDATA[var_type(arg0, arg1,...) - returns a list of integers that show the type of
                           each argument.]]>
        </body>
    </entry>
    <entry id="break">
        <body>
 <![CDATA[break() - immediately terminates a loop.
See also: continue, return]]>
        </body>
    </entry>
    <entry id="check_after">
        <body>
 <![CDATA[check_after(conditional) - in loops, this means that the conditional is checked
                           at the end of an interation rather than before the
                           iteration. This effectively gives a post-positional
                           loop.]]>
        </body>
    </entry>
    <entry id="common_keys">
        <body>
 <![CDATA[common_keys(stem1., stem2.) - returns a list of keys common to both stems.]]>
        </body>
    </entry>
    <entry id="contains">
        <body>
 <![CDATA[contains(source, snippets) - returns a conformable result for any combination
                             of stems and strings. If both arguments are
                             string, the result is a boolean. If source is a
                             stem and snippets is a string, then the result is
                             a boolean stem with a true for each entry that
                             contains the snippet etc.
contains(source, snippets, case_sensitive) -- if case_sensitive is true, which
                             is the default, all testing is done preserving
                             case. If false, all arguments are converted to
                             lower case first.
Note: Original arguments are never altered.]]>
        </body>
    </entry>
    <entry id="continue">
        <body>
 <![CDATA[continue() - jumps to the next iteration in a loop

See also: break, return]]>
        </body>
    </entry>
    <entry id="for_keys">
        <body>
 <![CDATA[for_keys(var, stem.)

  var - is a simple variable and will contain the current key during the loop.
        If it has already been defined, its values will be over-written.
stem. - is a stem variable. The keys of this stem will be assigned to the var
        and may be accessed  in the loop.
Note: This only operates inside of looping constructs.

See also: for_next, to loop over values of the stem]]>
        </body>
    </entry>
    <entry id="for_next">
        <body>
 <![CDATA[There are two versions. The first allows you to simply define the looping
parameters with integers, the second lets you use any list and iterate
over the values
Meth0d #1:
----------
for_next(var, stop_value {,start_value, increment})
        var - the variable to be used. As the loop is executed, this value will
              change.
 stop_value - the final value for the loop. When the variable acquires this value,
              the loop is terminated (so the loop body does not execute with
              this value!)
start_value - (optional, default is 0). The first value assigned to var.
  increment - (optional, default is 1). How much the loop variable should be
              incremented on each iteration.

Method #2:
----------
for_next(var, arg.)
        var - the variable to be used. As the loop is executed, this value will
              change.
        arg. - any stem. The keys are iterated over and the values are
               assigned to var.

Note: This only functions in looping constructs.

See also: for_keys to loop over the keys in a stem.]]>
        </body>
    </entry>
    <entry id="index_of">
        <body>
<![CDATA[index_of(source, snippets) - returns a conformable stem of lists of integers giving the
                  location of the snippet or a -1 if the snippet is not found.
index_of(source, snippets, case_sensitive) - if true (default) all comparisons
                  are case sensitive. If false, all are converted to lower
                  case first.]]>
        </body>
        <example>
<![CDATA[     // There is exactly on 'pp' in the argument
     index_of('ragg mopp ragmop!', 'pp')
[7]
      index_of('The cow is of the bovine ilk; One end is moo, the other, milk', 'the', false)
 [0,14,46,51]
           index_of('The cow is of the bovine ilk; One end is moo, the other, milk', 'the')
[14,46,51]]]>
        </example>
    </entry>
    <entry id="module_import">
        <body>
 <![CDATA[module_import(urn)- import the given module using its default alias.
module_import(urn, alias) - import the module, assigning it a different alias.
module_import(arg.) - import a bunch of modules in a stem
Note: A module must be loaded before it can be imported or the system does not
      know about it.

E.g.
  module_import(urn0, [urn1, 'curves'], [urn2. 'complex'])

This will import 3 modules with urn0, urn1 and urn2. urn0 is importe
with the default alias, urn1 and urn2 are imported with the specified
aliases.
Returns:
  - null if nothing imported
  - a list of aliases that were imported that corresponds to the input arg.]]>
        </body>
    </entry>
    <entry id="module_remove">
        <body>
 <![CDATA[module_remove(string | stem.) - remove the alias for the module from the
    workspace. Attempts to access it later will result in an error.]]>
        </body>
    </entry>

    <entry id="module_load">
        <body>
 <![CDATA[module_load(path) - load the module into the current session from the given
                    file. It cannot be used until it is imported.
module_load(path, type) - load the module. If type is 'file' (default) then
                    this is assumed to be QDL and loaded. If the type is 'java'
                    then the path is actually the fully qualified class name
                    and this is loaded from the Java virtual machine.
module_load([[path0{,type0}],path1{,type1}], . . . [pathn{,typen}]])
          load all of the given modules. The typek are optional.
Modules defined outside of the running QDL session must be loaded before being
imported, since you may import multiple instances of the module with
different aliases.

Returns:
  - null if nothing loaded
  - fully qualified name  of the loaded module
  - stem of fully qualified names (if there are multiple modules in the file).

E.g. load and import a module
   module_import(module_load('complex'))
complex

This looks for the module named complex then complex.mdl in the module
path and loads it. It then imports an instance using the default alias
the result is the name of the module in the session.

See also:module_import]]>
        </body>
    </entry>
    <entry id="raise_error">
        <body>
 <![CDATA[raise_error(message) - raises an error and propagates the message in to the
                       catch block
raise_error(message, code) - add and option numeric code
Note: This ONLY works inside a try[ ... ]catch[] block

Inside the catch block the message and code arguments are accsesible as
error_message
error_code

The error_code of -1 is reserved by the system. If an assertion fails then
that is treated like a system error with reserved value of -2.

See also:try, catch]]>
        </body>
<example>
<![CDATA[E.g. Catch an arithmetic error:
   try[3/0;]catch[if[error_code==-1]then[say(error_message);];];
divide by zero

E.g. How to handle mutliple conditions. we are simply
echoing the error_message, but yo can have any processing at that point
you need/want

j := 41;
try[
     remainder := mod(j, 3);
     if[remainder == 0][say('A remainder of 0 is fine.');];
     if[remainder == 1][raise_error(j + ' not divisible by 3, R==1', 1);];
     if[remainder == 2][raise_error(j + ' not divisible by 3, R==2', 2);];
 ]catch[
    if[error_code == 1][say(error_message);];
    if[error_code == 2][say(error_message);];
 ]; // end catch block
41 not divisible by 3, R==2

]]>
</example>

    </entry>
    <entry id="return">
        <body>
 <![CDATA[return() - return from a function with no value.
return(value)  - return value from this function as the result
Note: This only works for functions.

See also: continue, break]]>
        </body>
    </entry>
    <entry id="replace">
        <body>
 <![CDATA[replace(source, old, new) - replaces all occurences of old with new in the
                            source. These may be various combinations of stems
                            and strings.

replace(source, regex, new, is_regex) - when is_regex == true,
                            replaces all matching occurences with
                            the regex with new in the source. These may be
                            various combinations of stems and strings.
If is_regex is false, then no regular expressions are used and matching is
as simple strings.

See also: =~, tokenize]]>
        </body>
<example>
<![CDATA[   replace('abcde', 'cd', '23');
ab23e

E.g. Use a regex - replace all blanks with a single period.
  replace('a b c  d e fgh', '\\s+', '.', true)
a.b.c.d.e.fgh]]>
</example>

    </entry>
    <entry id="substring">
        <body>
 <![CDATA[substring(arg, n) - take a substring of the arg starting at the given index, n,
                    and going to the rest of the string. This will also be
                    done on each element if arg is a stem.
substring(arg, n,length) - start the substring at index n and continue for
                    length characters. If no n + length > size(arg) and
                    no padding, just return the rest of the string
substring(arg, n ,length ,padding) - start at the index, retrieve length
                    characters and if there are not enough, cyclically pad the
                    result with the string padding.]]>
        </body>
<example>
<![CDATA[   substring('abcdefg',3)
defg
   substring('abcdefg',3,2)
de
   substring('abcdefg',3,10); // asking for more characters than available
defg
  substring('abcdefg',3,11,'pqr'); // padding with string cyclically
defgpqrpqrp
  substring(['abc','pqr'],1,5,'tuv'); // works on lists and stems
[bctuv,qrtuv]]]>
</example>

    </entry>
    <entry id="to_lower">
        <body>
 <![CDATA[to_lower(arg) - convert a string or stem of strings to lower case. No effect
                on non-strings.

See also: to_upper]]>
        </body>
    </entry>
    <entry id="to_upper">
        <body>
 <![CDATA[to_upper(arg) - convert a string or stem of strings to upper case. No effect
                on non-strings.

See also: to_upper]]>
        </body>
    </entry>
    <entry id="tokenize">
        <body>
 <![CDATA[tokenize(arg, delimiter) - tokenize a string or stem of strings using
                           the given delimeter.
       arg - the string to tokenize
       delimiter - either the delimiter or if the last argument is true,

tokenize(target, arg{, use_regex}) - tokenize a string or stem of strings
                           using the given regex
    target - the string to tokenize
       arg - either the delimiter (use_regex == false) or a regular expression
             (use_regex == true)
     use_regex - flag to use regex.]]>
        </body>
<example>
<![CDATA[   tokenize('abd:def:123', ':');
[abd,def,123]

   // Tokenize a string with various delimters using a regular expression

   a := 'a d, m, i.n';
   r := '\\s+|,\\s*|\\.\\s*';
   tokenize(a,r,true);
[a,d,m,i,n]]]>
</example>

    </entry>

    <entry id="detokenize">
        <body>
 <![CDATA[detokenize(arg, delimiter) - converts  a string or stem of strings (tokens)
                             into a string using the delimiter between entries.
detokenize(arg, delimiter, options) - options is an integer which is the sum of
          1 for prepend
          2 for omit dangling delimiter
So options = 0 means append, have a trailing delimiter
   options = 1 means prepend, "   "     leading "
   options = 2 means append, omit trailing delimiter
   options = 3 means prepend, omit first delimiter

See also: tokenize, constants (which contains the option values for reference)]]>
        </body>
<example>
<![CDATA[   detokenize([;4],'|')
0|1|2|3|

// Note the trailing | added at the end.

   detokenize([;4]], '|',2)
0|1|2|3

omits the trailing |.]]>
</example>

    </entry>
    <entry id="trim">
        <body>
 <![CDATA[trim(arg) - remove all leading and trailing blanks from the arg. The argument
            may also be a stem of strings.

Remember that the "-" operator will remove characters in the middle as well
while trim() just removes from the ends.]]>
        </body>
    </entry>

    <!--
         Variable entries
    -->
    <entry id="pp">
        <body>
 <![CDATA[(workspace variable)
pp - short form for pretty_print.

See also: pretty_print]]>
        </body>
    </entry>

    <entry id="pretty_print">
        <body>
 <![CDATA[(workspace variable)
pretty_print - toggle printing stems on one line (off | false) or
               vertically (on | true).
pp is the short form for this.]]>
        </body>
    </entry>
    <entry id="echo">
        <body>
 <![CDATA[(workspace variable)
echo - toggle echo mode in the workspace. If (on | true), this allows you to
       enter QDL commands without the final semi-colon (;) and the result is
       printed to the console. The default is on.]]>
        </body>
    </entry>

    <entry id="ws_id">
        <body>
 <![CDATA[(workspace variable)
ws_id - the internal identifier for this workspace. This is especially useful
        if the file name is munged or strange.

See also: name, description]]>
        </body>
    </entry>
    <entry id="description">
        <body>
 <![CDATA[(workspace variable)
description - A human readable description of this workspace. This is printed
              on load if present. It should tell the user what the workspace
              does for instance. Note that you can set it using a QDL variable
              too so
E.g.
    )ws set description >my_descr.

Would set the contents of this to the list of strings given. Note that this
will be turned into a single string with linefeeds after each entry.]]>
        </body>
    </entry>
    <entry id="debug">
        <body>
 <![CDATA[Either a workspace variable or the system command to manage debugging
System command:
debug([level , message])
     no args = print out current debug level
       level = an integer in the range 0 (no output) to 5 (trace mode)
               that determines the level of debugging output
     message = A string that contains the entry to the debug log.
See also: log_entry

Workspace variable:
debug - Toggle low-level debugging of the innards of the workspace and QDL.
        This is only useful if you are having a serious issue (such as
        writing a Java module and need to see stack traces). This may be
        (on | true) or (off | false). Generally you do not need this.]]>
        </body>
    </entry>

    <entry id="start_ts">
        <body>
 <![CDATA[(workspace variable)
start_ts - The time stamp when this was first created. You *may* change this,
           but probably just want the system to manage. Set it using either
           as an integer (in milliseconds) or as an ISO 8601 date.]]>
        </body>
    </entry>
    <entry id="root_dir">
        <body>
 <![CDATA[(workspace variable)
root_dir - The root directory for all relative file directories. If you attempt
           to save the workspace and the file name is relative (so does not
           e.g., start with a /) then it is assumed to reside in this
           directory. At startup, this is set to the directory where QDL
           was started by default.
E.g.

)save ws/var/my_ws.zml

            would resolve this to root_dir/ws/var/my_ws.zml when saving it.]]>
        </body>
    </entry>

    <entry id="save_dir">
        <body>
 <![CDATA[(workspace variable)
save_dir - The default directory for saving and loading files. This is set
           at startup automatically This overrides relativizing the path
           from the root_dir.]]>
        </body>
    </entry>

    <entry id="autosave_on">
        <body>
 <![CDATA[(workspace variable)
autosave_on - Turn on automatically saving workspace. If on then every time the
              autosave_interval (measured in milliseconds) passes, the current
              workspace is saved.
See also: autosave_messages_on, autosave_interval]]>
        </body>
    </entry>

    <entry id="autosave_messages_on">
        <body>
 <![CDATA[(workspace variable)
autosave_messages_on - Turn on notifications by the autosave system. If on then
             every time the workspace is automatically saved, the usual
             messages (size, time) are printed. If false, nothing is printed.

See also: autosave_on, autosave_interval]]>
        </body>
    </entry>

    <entry id="autosave_interval">
        <body>
 <![CDATA[(workspace variable)
autosave_interval - The interval in either seconds or milliseconds that
                    determines how often the workspace is saved. The default
                    is 10 minutes or 600000 ms. You may enter this as
                    milliseconds (default units) or as seconds.
E.g.
   )ws set autosave_interval 900 sec.

             Would set the autosave interval to 900 seconds or 15 minutes.
             See also: autosave_on, autosave_interval]]>
        </body>
    </entry>

    <entry id="compress_xml">
        <body>
 <![CDATA[(workspace variable)
compress_xml - toggle compression of XML on WS save. Options are (on | true)
               or (off | false). Note that on loading workspaces, this not used
                -- the workspace will figure out if it was saved with
                compression and decompress it, so you don't have to worry about
               the compression of stored workspaces.]]>
        </body>
    </entry>
    <entry id="enable_library_support">
        <body>
 <![CDATA[(workspace variable)
enable_library_support - enable on the fly resolution of scripts as if they
               were functions. You must set the lib_path as well for
               this to work.

See also: lib_path]]>
        </body>
    </entry>
    <entry id="lib_path">
        <body>
 <![CDATA[(workspace variable)
lib_path - the paths that are used in resolving library references. A library
           is a collection of QDL scripts, each ending with .qdl. If library
           support is enabled then calls to scripts are resolved dynamically.
           See the reference manual for full details.
E.g.
   if you have a lib_path set and there is a file called sqrt.qdl that accepts
    a single number and returns it square root, then you could invoke it for
    the value of x with
       sqrt(x)
   You could do this directly as
       script_run('/path/to/sqrt.qdl', x)

See also: enable_library_support]]>
        </body>
    </entry>
    <entry id="ws_file">
        <body>
 <![CDATA[(workspace variable)
ws_file - the current file to save to/load from by default. If you save or load a file
          this is set to that value. You may then issue commands like

)save

          (so no file argument) and the workspace is saved. Note that this is independent of the
          save_dir, which used for resolving all relative path loads and saves.]]>
        </body>
    </entry>
    <entry id="reduce">
        <body>
 <![CDATA[reduce(@f, arg) - Apply the function between all elements of the set
    or generic (i.e. not a list) argument, stem, set or (trivially) scalar.
    The result is always a scalar.
reduce(@f(), list. {,axis}) - Takes a dyadic function f and applied it between
             successive members of the list (i.e. in order).
             The final result is a scalar.

See also: expand()]]>
        </body>
<example>
<![CDATA[E.g.
Are all elements of a boolean list true?
   a. := -1 < n(5); // list of boolean true values
   reduce(@&&, a.)
true
This applies && between each element.

E.g. on a set
   reduce(@*, {1,2,3,4,5})
120
E.g. on a stem
   reduce(@+, {'foo':'a', 'bar':'b', 'baz':'c'})
bac
Do remember that for this (rather simple-minded) case, since there
is *no* canonical ordering of elements in a stem, the result is
a more or less random concatenation of the elements.

E.g. On a higher dimension list
  q. := n(3,4,n(12));
  q.
[[0,1,2,3],
 [4,5,6,7],
 [8,9,10,11]]
  reduce(@+, q., 0); //apply to 0th axis (also default), sum columns
[12,15,18,21]
  reduce(@+, q., 1); // apply to first axis, so sum the rows
[6,
 22,
 38]]]>
</example>

    </entry>
    <entry id="expand">
        <body>
 <![CDATA[expand(@f, list.) = apply the dyadic function f() pairwise and return the
              intermediate results.


E.g. To compute the factorial of a number and see the parts:
   expand(@*, 1+n(5))
[1, 2, 6, 24, 120]

In this case [1, 2, 3, 4, 5] becomes [1, 1*2, 1*2*3, 1*2*3*4, 1*2*3*4*5]
Note that reduce() effectively returns just the final number. Using expand
lets you use the intermediate results too.

Note that it is not possible to apply expand to a set or a generic stem,
(what would it mean to stash intermediate results in random keys??)
so attempts to do so will result in an exception.

See also: reduce]]>
        </body>
    </entry>
    <entry id="sin">
        <body>
 <![CDATA[sin(x) - the sine of x
x can be any number.

See also: asin()]]>
        </body>
    </entry>
    <entry id="asin">
        <body>
 <![CDATA[asin(x) - the arc sine of x. The result in in radians.
-1 <= x <= 1.

See also: sin()]]>
        </body>
    </entry>
    <entry id="sinh">
        <body>
 <![CDATA[sinh(x) - the hyperbolic sine of x
x can be any number.

See also: asinh()]]>
        </body>
    </entry>
    <entry id="asinh">
        <body>
 <![CDATA[asin(x) - the inverse of sinh of x.
x can be any number

See also: sinh()]]>
        </body>
    </entry>

    <entry id="cos">
        <body>
 <![CDATA[cos(x) - the cosine of x
x can be any number.

See also: acos()]]>
        </body>
    </entry>
    <entry id="acos">
        <body>
 <![CDATA[acos(x) - the arc cosine of x. The result in in radians.
-1 <= x <= 1.

See also: cos()]]>
        </body>
    </entry>
    <entry id="cosh">
        <body>
 <![CDATA[cosh(x) - the hyperbolic cosine of x
x can be any number.

See also: acosh()]]>
        </body>
    </entry>
    <entry id="acosh">
        <body>
 <![CDATA[acosh(x) - the inverse of cosh of x.
1 <= x

See also: cosh()]]>
        </body>
    </entry>

    <entry id="tan">
        <body>
 <![CDATA[tan(x) - the tangent of x
x can be any number.

See also: atan()]]>
        </body>
    </entry>
    <entry id="atan">
        <body>
 <![CDATA[atan(x) - the arc tangent of x. The result in in radians.
x can be any number.

See also: tan()]]>
        </body>
    </entry>
    <entry id="tanh">
        <body>
 <![CDATA[tanh(x) - the hyperbolic tangent of x
x can be any number

See also: atanh()]]>
        </body>
    </entry>
    <entry id="atanh">
        <body>
 <![CDATA[atanh(x) - the inverse of tanh of x.
-1 < x < 1

See also: tanh()]]>
        </body>
    </entry>

    <entry id="pi">
        <body>
 <![CDATA[pi({n}) - the value of pi in the current precision
       raised to the power n.

 If n is omitted, then it is assumed to be 1.]]>
        </body>
    </entry>
    <entry id="exp">
        <body>
 <![CDATA[ exp() - the value of  e, the base of the natural logarithm
exp(x) - the value of e^x

x can be any number.

See also: ln(), log()]]>
        </body>
    </entry>
    <entry id="ln">
        <body>
 <![CDATA[ln(x) - the natural logarithm of x
0 < x

See also: exp(), log()]]>
        </body>
    </entry>

    <entry id="log">
        <body>
 <![CDATA[log(x) - the base 10 logarithm of x
0 < x
Note that QDL support arbitrary exponentiation, so unlike ln(x), there is no
explicit inverse. The inverse is 10^x.
If you need a different base, divide by the log of the base,
E.g.
  To get log base 2 of 8:
  log(8)/log(2)
3.00000000001
See also: ln(), exp()]]>
        </body>
    </entry>

    <entry id="log_entry">
        <body>
 <![CDATA[log_entry(level, message) - put a message in the current log.

See also: debug (system command)]]>
        </body>
    </entry>

    <entry id="nroot">
        <body>
 <![CDATA[nroot(x,n) - compute the n-th root of x.
             n is an integer.
             If n is odd, x may be any number,
             If n is even, 0 <= 0
The general case of exponentiation x^y will fail for fractional roots and
negative numbers. This is because there is no way to check if an exponent
is an n-th root, due to internal computer representation not being exact,
so
    (-5)^(1/3)
will fail (because 1/3 cannot be represented fully in the computer).
nroot(x,n) explicitly checks, so
   nroot(-5,3)
-1.70997594667670
works.

See also: Reference manual on ^]]>
        </body>
    </entry>
    <entry id="join">
        <body>
 <![CDATA[join(x., y.{, axis}) - join two stems together along a given axis.
See also: union or the ~ operator. Those are special cases of
join(x., y., 0 ) == x.~y. == join(x., y.)
Omitting axis means use axis 0. Join makes the axis bigger:

There is also the laminate function in the extension module for pasting
two stems together along a new axis.

See also: ~. ~|
]]>
        </body>
<example>
<![CDATA[E.g.
   join(n(3,4,[;12]), n(3,5,[10;25]))
[
  [0,1,2,3],
  [4,5,6,7],
  [8,9,10,11],
  [10,11,12,13,14],
  [15,16,17,18,19],
  [20,21,22,23,24]
]

This joins along the zero-th axis and the resulting size of the zeroth
axis is  5 = 3+2.

Compare to joining along the last axis
  join(n(3,4,[;12]), n(3,5,[10;25]), -1)
[
  [0,1,2,3,10,11,12,13,14],
  [4,5,6,7,15,16,17,18,19],
  [8,9,10,11,20,21,22,23,24]
 ]

 Here the -1 (last) axis (which is also the 1-th axis or columns here)
 is augmented and the dimension is 3 x (4+5).]]>
</example>

    </entry>
    <entry id="reverse">
        <body>
 <![CDATA[reverse(list.) - reverse the elements of a list]]>
        </body>
<example>
<![CDATA[E.g.
  reverse(n(5))
[4,3,2,1,0]
Another example on a list of lists
  p. := [n(3),n(2)]
  p.
[[0,1,2], [0,1]]
  reverse(p.)
[[0,1],[0,1,2]]]]>
</example>

    </entry>
    <entry id="dim">
        <body>
 <![CDATA[dim(list.) - The dimension of a list. This returns a list of the size of each
             zeroth component. In the case of non-ragged lists, this is
             precisely the number of elements per entry.

Note: This is only a partial result with ragged arrays, since there is no
      good way to get a single canonical size.]]>
        </body>
<example>
<![CDATA[E.g.
    dim(n(5))
[5]
Because this has a single index and it is 5 elements long.
     dim(n(3,4,5))
[3,4,5]
This is a list of the indices (three) with the counts in them.]]>
</example>

    </entry>
    <entry id="rank">
        <body>
 <![CDATA[rank(list.) - returns the number (a scalar) of independent indices,
              i.e. size(dim(list.))
E.g.
   rank(n(3,4,5))
3
This means there are three separate indices.]]>
        </body>
    </entry>
    <entry id="query">
        <body>
 <![CDATA[query(arg., query_string{,return_indices}) -- do a query on a stem using
            JSON Path syntax.
          arg. - the stem to search
  query_string - a valid JSON Path query string as per
     https://tools.ietf.org/id/draft-goessner-dispatch-jsonpath-00.html
(A copy of this as jsonpath.pdf is deployed to your docs directory in a standard
install, mostly because things on the web can go away.)
return_indices - (optional) return the indices of the result, not the result.
Returns a list.

This allows you to query stems using the standard query language in JSON.
You supply a stem and a query. Note that the query is a string.
]]>
        </body>
        <example>
           <![CDATA[In section 2 of the above specification is a JSON object. If you import
this into the workspace as the stem variable my_json., then here are
a few examples:

E.g. 1: getting a result set
   query(test., '$..book[?(@.isbn)]'); // get books with an isbn number
[
  {
  author:Herman Melville,
  price:8.99,
  isbn:0-553-21311-3,...

  Note well that results are returned as stem lists of paths.

E.g. 2: Getting the indices
  ndx. := query(test., '$..book[?(@.isbn)]', true); // Just get the indices
  ndx.
[[store,book,2],[store,book,3]]

E.g. 3: Using the indices
   my_json.ndx.0
{
  author:Herman Melville,
  price:8.99,
  isbn:0-553-21311-3,...

Hint: Easy way to import the JSON is to cut and paste it to a file at /my/path/my_json.json
       and issue
       my_json. := from_json(file_read('/my/path/my_json.json'));]]>
                </example>

    </entry>
    <entry id="=~" alt="≈">

        <body>
 <![CDATA[regex =~ expression
Apply the given regex (which is a string) to match the string representation
of the expression.
Result is always a boolean.

See also: tokenize, replace.]]>
        </body>
        <example>
           <![CDATA[   '[a-zA-Z]{3}' =~ 'aBc'; // Checks if the argument has 3 letters
true
           ]]>
                </example>

    </entry>

    <entry id="[|" alt="⟦">
        <body>
 <![CDATA[Closed slice notation.
Equivalent to: [|
You may use ⟦ (\u27e6) or [| ,  ⟧ (\u27e7) or |].
⟦ start;stop;count ⟧
will create the list with count elements evenly distributed between start and stop,
inclusive.
See also: slice]]>
        </body>
        <example>
           <![CDATA[   ⟦-1/2; 1/pi(); 5⟧
[-0.5,-0.295422528454052,-0.090845056908104,0.113732414637844,0.318309886183792]

Yields 5 numbers from -1/2 to 1/pi inclusive.]]>
                </example>

    </entry>
    <entry id="|]" alt="⟧">
        <body>
 <![CDATA[Closed slice operator close bracket.
See slice]]>
        </body>
    </entry>


    <entry id="!" alt="¬">
        <body>
 <![CDATA[Unary negation. Note that this is a monadic operator (!).
That means that it negates it right hand argument, so the order
of operations using this is a wee bit different from what you might
expect. For instance

! true && false == !(true && false) == true

which is not

(! true) && false == false

When in doubt, use parentheses. Again, the contract is that the entire
RHS is evaluated and fed to the operator. Compare the tilde operator
for lists or any of the other monadic operators.

Equivalent to: unicode not ¬ or \u00ac]]>
        </body>
    </entry>
    <entry id="*" alt="×">
        <body>
 <![CDATA[a*b
 For numbers, multiplication.
 For strings, this will return b copies of a, or a copies of b
]]>
        </body>
<example>
<![CDATA[   2*3
6
   4*'abc'
abcabcabcabc]]>
</example>

    </entry>
    <entry id = "/" alt="÷">
        <body>
 <![CDATA[Division. You know, division
   17/91
 0.186813186813186

 For sets, A/B is all elements in A not in B:
    {1,3,'a','b',7}/{'a','b','c','d'}
 {1,3,7}

 See also /\ (intersection), % (symmetric difference)]]>
        </body>
    </entry>
    <entry id=":=" alt="≔">
        <body>
 <![CDATA[a := b - left assignment

 a is assigned the value of b. Note that the colon goes next to the variable.]]>
        </body>
    </entry>
    <entry id="=:" alt="≕">
        <body>
 <![CDATA[a =: b - right assignment

b is assigned the value of a. Note that the colon goes next to the variable.]]>
        </body>
    </entry>
    <entry id="&amp;&amp;" alt="∧">
        <body>
 <![CDATA[a && b - boolean and applied to a and b

 Both a and b arguments must be booleans.]]>
        </body>
    </entry>
    <entry id = "||" alt="∨">
        <body>
 <![CDATA[a || b - logical or applied to a and b

 Both a and b must be booleans.]]>
        </body>
    </entry>

    <entry id="{}" alt="∅">
        <body>
 <![CDATA[The empty or null set. This is the set with no elements. It is a proper
subset of every set except itself.]]>
        </body>
    </entry>
    <entry id="&lt;=" alt="≤">
        <body>
 <![CDATA[a <= b - comparison of a less than or equal to b

See also: comparisons]]>
        </body>
    </entry>
    <entry id="&gt;=" alt="≥">
        <body>
 <![CDATA[a >= b - comparison for a greater than or equal to be.

See also: comparisons
]]>
        </body>
    </entry>
    <entry id="!=" alt="≠">
        <body>
 <![CDATA[a != b - a is not equal to b.

See also: comparisons]]>
        </body>
    </entry>


    <entry id="unicode">
        <body>
 <![CDATA[Unicode characters may be put in strings if they are escaped.
QDL also supports several directly as operators. Typing them is, however
dependant on your keyboard layout. Generally every unicode character has
an ASCII version (usually a digraph).

Here is a table of supported unicode characters in QDL:

Standard    Unicode   ALT   escape code    What is it
               »       '    \u00bb         FDoc start of line
!              ¬       !    \u00ac         logical not
-              ¯       -    \u00af         unary minus
`              ·       .    \u00b7         raised dot
*              ×       *    \u00d7         multiplication
/              ÷       /    \u00f7         division
+              ⁺       +    \u207a         unary plus
assert[][]     ⊨       a    \u22a8         assert
->             →       d    \u2192         lambda function
%              ∆       D    \u2206         symmetric difference operator
               ∈       e    \u2208         is member of
               ∉       E    \u2209         is *not* member of
/\             ∩       i    \u2229         set intersection
{}             ∅       n    \u2205         null set
\/             ∪       u    \u222a         set union
&&             ∧       &    \u2227         logical and
||             ∨       |    \u2228         logical or
=~             ≈       ?    \u2248         regex matches
:=             ≔       :    \u2254         left assignment
=:             ≕       "    \u2255         right assignment
!=             ≠       \    \u2260         not equal to
==             ≡       =    \u2261         logical equality
<=             ≤       <    \u2264         less than or equals
>=             ≥       >    \u2265         greater than or equals
~|             ≁       ~    \u2241         last axis join
@              ⊗       @    \u2297         function reference
[|             ⟦       {    \u27e6         left closed slice bracket
|]             ⟧       }    \u27e7         right closed slice bracket
ceiling        ⌈       k    \u2308         ceiling
floor          ⌊       l    \u230a         floor
|^             ⊢       s    \u22a2         create a set
transpose      τ       t    \u03c4         alias for the transpose function.
pi             π       p    \u03c0         Greek letter pi.


The ALT keys are only available if you are running QDL in ANSI mode. So
alt+d inserts the definition arrow, for instance. Note that if you
are running ANSI mode, the ALT keys do not work in external editors,
since the mapping is local to QDL (or it might really screw up your system).

You can request help on any QDL symbol by typing
    )help symbol
E.g.
    )help ∅
    
would print the entry for the null set.]]>
        </body>
        <example>
           <![CDATA[   // How to use unicode in a string:
   '\u03c4 is the Greek letter tau'
τ is the Greek letter tau]]>
                </example>

    </entry>

    <entry id="assert" alt="⊨">
        <body>
 <![CDATA[assert[boolean][expression]
or
⊨ boolean : expression

is a directive that tells the system to fail if the boolean is false. The
result will be an error returned with the expression evaluated (if possible)
and turned into a string.
E.g.
assert[ script_args() == 2 ]['You must supply both a username and password.'];

This stops further processing and essentially allows you to introduce and
unrecoverable error if needed.

If an assertion is made in a try-catch statement, then an error is raised
with reserved error_code of -2 and the message is propagated like
any other error message.

Assertions may be globally turned off and on with the assertions_on variable
in the workspace, or as a configuration option. One common use is to have
them on for development and off in production.]]>
        </body>
        <example>
<![CDATA[⊨ script_arg() ≡  2 : 'you must supply both a username and password';

alternately

assert[script_arg() ≡  2 ][ 'you must supply both a username and password'];]]>
        </example>
    </entry>

    <entry id="for_each">
        <body>
 <![CDATA[for_each(@f, arg_1., arg_2., ..., arg_n.) - Apply the n-adic function, f, to
           each element of the outer product of the arg_k.
Simple example, making a multiplication table.
   a. := for_each(@*, 1+n(5), 1+n(6))
   a.
[
   [1,2,3,4,5,6],
   [2,4,6,8,10,12],
   [3,6,9,12,15,18],
   [4,8,12,16,20,24],
   [5,10,15,20,25,30]
]

Things to note. The result is the product of the stems, so here there is
a 5 x 6 array that results. a.i.j is the product of the i-th and j-th elements.

Another example. Create the grid points for a quadric (polynomial) surface over
a a region.
   z(x,y) -> x*y;
   z. := for_each(@z, [|-1;1;15|],[0;3;0.25])
   dim(z.)
[15,12]
This creates a table over the region of the plane for -1 <= x <= 1
and 0 <= y < 3. There are 15 total points in the x direction and
the y direction is done in increments of 0.25, resulting in 12 values,
so the result is a 15 x 12 array, with z evaluated at each point.

To get the xy grid, use ~ to stick the x and y coordinates together:

   xy. := for_each(@~, [|-1;1;15|],[0;3;0.25])
   dim(xy.)
[15,12,2]

and z.i.j is the value of z() at xy.i.j, i.e. z.i.j == z(xy.i.j.0, xy.i.j.1)]]>
        </body>
    </entry>
    <entry id="block">
        <body>
 <![CDATA[Keyword.
block is a reserved work to denote the beginning of a local environment.
It is set off with []. Anything defined inside the block is local only
to that block, but the block inherits the ambient state.
E.g.
   a := 'foo';
   block[a := 'baz'; ok := true;];
   is_defined(ok);
false
   a
baz

a gets re-assigned to 'baz' inside the block, ok does not exist any place but the block.
This is extremely useful in many places, such as scripts.

See also: local, visibility]]>
        </body>
    </entry>

    <entry id="slice">
        <body>
 <![CDATA[A slice is an list of numbers. There are two main types
Open slice: [start;stop;step]
which will produce the list
[start, start+step, start +2*step, ... ]
ending when stop < start + n*step.
If start is omitted, it is assumed to be 0 (zero).
If step is omitted, it is assumed to be 1.

Closed slice [|start;stop;count|]
This will produce the list from
[start, ... , stop] (inclusive)
and will have exactly count element in it.
If start is omitted, it is assumed to be 0 (zero).

See also [|, |], ⟦, ⟧]]>
        </body>
        <example>
<![CDATA[E.g. Open slice examples
   [;5]
[0,1,2,3,4]
  //using a slice in a loop
  while[for_next(j, 1+2*[;4])][say(j);]
1
3
5
7
  [2;5;0.7]
[2,2.7,3.4,4.1,4.8]
Note well: in an open slice, you do not necessarily know how
           many elements are in the resulting list. Here there
           are 5.

E.g. Closed slices example
  [|-pi()/4; pi()/3; 11 |]
[-0.785398163397447,-0.602138591938043, ... ,1.047197551196593]

produces a list of 11 equally spaced numbers from -pi/4 to pi/3,
including the endpoints.]]>
        </example>
    </entry>
    <entry id="differ_at">
        <body>
 <![CDATA[differ_at(s0, s1) - find first index at which two strings differ. If the
               strings are equal then a value of -1 is returned.
               Read: 's0 and s1 differ at index i'
               If one string is a substring of
               another, then the index is the length (i.e. this is the index
               in the longer string). You may also apply this to stems
               of strings.]]>
        </body>
<example>
<![CDATA[   differ_at('abcde', 'ab')
2
   differ_at('abcd','abcd')
-1
  differ_at(['abcde','abed'], 'abcq')
[3,2]
   // A somewhat larger example.
   q. := ['abcd','efghij']
   s. := ['abq','efgp']
   differ_at(q.,s.)
[2,3]
   // How to use this to get rid of the common parts of strings,
  substring(q., differ_at(q.,s.))
[cd,hij]]]>
</example>
    </entry>

    <entry id="version">
        <body>
 <![CDATA[The current version of QDL is 1.4.7.1]]>
        </body>
    </entry>
    <entry id="if">
        <body>
 <![CDATA[Keyword.
Denotes a conditional statement:
Basic conditional
   if[ boolean ][ (statement;)*];
Conditional with an else clause
   if[ boolean ][ (statement;)*]else[ (statement;)*];

Note there is no semi-colon after the conditional.

See also: then, else, ?]]>
        </body>
    </entry>
    <entry id="?">
        <body>
<![CDATA[Used in the ternary operator
   boolean ? expression0 : expression1
   boolean. ? expression0 : expression1
If boolean is true, then expression0 is evaluated and returned. Otherwise
expression1 is used.

    user_name := script_args() == 2 ? script_args(1) : 'guest';

These may be used like any other algebraic expression, where the if statement
cannot be.

If the left argument is a stem (list or simple stem) then a conformable
result is returned.
    a.0 := false; a.'foo' := true; a.3 := false;
    a.?[-2;2]:'bar'

{foo: [-2,-1,0,1], 0:bar, 3:bar}

Note that expression0 and expression1 are not subject to subsetting, they
are returned as is.

See also: if, then, else]]>
        </body>
        <example>
<![CDATA[For a list of strings, add a trailing slash if one is missing.
   p. := ['a:/x/y','a:/x/z/','b:/p/q']
   p.+('.*/' =~ p.?'':'/');// regex to test if an element ends with a slash
[a:/x/y/,a:/x/z/,b:/p/q/]]]>
        </example>
    </entry>
    <entry id="then">
        <body>
 <![CDATA[Keyword.
Optional connector in conditional statements. It may be ommitted or not.
These are equivalent
   if[2 < 3][say('foo');];
   if[2 < 3]then[say('foo');];
You may have space around the then keyword.

See also: if, else, ?]]>
        </body>
    </entry>
    <entry id="else">
        <body>
 <![CDATA[Keyword.
This is used in conditional statements. It is optional in the sense that
not every conditional needs one, but if you do, it must be included, unlike
the then keyword.
   if[2<4][say('then');]else[say('else');];

See also: if, then, ?]]>
        </body>
    </entry>

    <entry id="while">
        <body>
 <![CDATA[Keyword.
This is used for QDL's looping  construction:
   while[ boolean ][(statement;)*];
or with the optional do keyword
   while[ boolean ]do[(statement;)*];
E.g.
All of these are the same:
   // loops that access the element directly
   while[j∈{2,3,4}][say(j);];
   while[for_next(j, [2;5])][say(j);];
   while[for_next(j, 5, 2)][say(j);];

   // loops that iterate over a stem (here just a list)
   index. := [2;5];
   while[has_value(j, index.)][say(index.j);];
   while[for_keys(j, index.)][say(index.j);];

   // looping directly
   i := 2;
   while[i< 5][say(i++);];

That said, you really should not need to loop much in QDL...

See also: do, for_next, for_keys, has_value, ∈, ∉, return]]>
        </body>
    </entry>
    <entry id="do">
        <body>
 <![CDATA[Keyword
Optional connector in while loops.  So these are the
same
   while[condition][statements]
   while[condition]do[statements]

See also: while]]>
        </body>
    </entry>
    <entry id="module">
        <body>
 <![CDATA[Keyword.
This is for the QDLs modules which are self-contained units of code:
module[uri, alias
  ][
  » General comments
  (statement;)*
];

Modules may have intrinsic (called private in other languages)
variables and functions if they start with __ to hide them.
To see the general comments for a module in the workspace type
   )modules uri|alias -help

See also: body, module_load, module_import, intrinsic.]]>
        </body>
    </entry>
    <entry id="body">
        <body>
 <![CDATA[Keyword.
Optional keyword connecting clauses in define and module statements.
E.g.
   define[f(x)][...
   define[f(x)]body[...

See also: define, ->]]>
        </body>
    </entry>
    <entry id="->" alt="→">
        <body>
 <![CDATA[Lambda function definition. A lambda function a user defined function:
   f(x)->cos(x);
would create a new function called f(x) which would evaluate the cosine
and automatically return it.
For multiple expressions, use [ ] and there is no automatic return:
   f(x)->[y:= x/2;return(cos(y));];
See also: define]]>
        </body>
    </entry>
    <entry id="keywords">
        <body>
 <![CDATA[The reserved keywords in QDL are

true    if     while   try     module   define   block
false   then   do      catch   body              local
null    else   assert

You may use the help facility for any of these.]]>
        </body>
    </entry>

    <entry id="try">
        <body>
 <![CDATA[Keyword
try denotes the QDLs exception handling statement.

   try[(statement;)*]catch[(statement;)*];

Note that the catch keyword is not optional. In this case, the statements in
the try[ ... ] block are done and only if there is an error, the statements
in the catch[ ... ] block are done.

   try[1/0;]catch[say('oops!');]
oops!

The raise_error function lets you have much more fine-grained handling of
errors.

See also: raise_error]]>
        </body>
    </entry>
    <entry id="catch">
        <body>
 <![CDATA[Keyword
Used as part of the try[ ... ] catch[ ... ] statement.
See also: try]]>
        </body>
    </entry>
    <entry id="true">
        <body>
 <![CDATA[Keyword
Logical true.

See also: false]]>
        </body>
    </entry>
    <entry id="false">
        <body>
 <![CDATA[Keyword
Logical false

See also: true]]>
        </body>
    </entry>
    <entry id="null">
        <body>
 <![CDATA[Keyword
The null is a special value that denotes that
no definite value has been assigned yet.
A common use is to define a variable to null to put it
in the correct scope for subsequent operations:
   a := null;
   if[2 < 3][a :=0;]else[a:=1;]
   a
0
Had a not been set to null first, then it would have only existed inside
the conditional and attempts to access it would result in an error.

See also: is_defined]]>
        </body>
    </entry>

    <entry id="values">
        <body>
 <![CDATA[values(arg) - return the values of a stem as a set

Note that if arg is a scalar, the result is a set of the value only.

This is a compliment to list_keys(arg.) which returns the keys as a list.
This will return *all* values in a stem, regardless of where they are.

To get all of their locations, use indices rather than keys since keys works
shallowly (only on first axis).

If you need to check that an element is in a list use has_value or ∈,
since those can be faster than getting every element, than checking
to see if one is in the set.

See also: list_keys, keys, indices, ∈, has_value]]>
        </body>
<example>
<![CDATA[E.g.
    zeta.'A' := ['p','q'];zeta.'B' := 'r';zeta.'C' := 's'
    values(zeta.)
{p,q,r,s}

E.g. values returned are unique.
  arg.foo := 2; arg.bar := 2; arg.baz := 2
  values(arg.)
{2}]]>
</example>

    </entry>
    <entry id="floor" alt="⌊">
        <body>
 <![CDATA[floor(arg) - compute the mathematical floor of the argument.
             This is the greatest integer less than or equal to it argument

Compare with the floor operator, ⌊, which behaves identically, but is not a function

    floor(-3.4)
-4
See also: ⌊, ceiling, ⌈
]]>
        </body>
<example>
<![CDATA[   floor(3.4)
3
   ⌊-3.4
-4
   ⌊[-2;3;0.7]
[-2,-2,-1,0,0,1,2,2]]]>
</example>

    </entry>

    <entry id="ceiling">
        <body>
 <![CDATA[ceiling(arg) - compute the ceiling of the argument.
               This is the least integer greater than or equal to arg.

See also: floor
]]>
        </body>
<example>
<![CDATA[E.g.
   ceiling(4.5)
5
   ceiling(-4.5)
-4
  ⌈[-2;3;0.7]
[-2,-1,0,1,1,2,3,3]]]>
</example>

    </entry>
    <entry id="%" alt="∆">
        <body>
 <![CDATA[Integer division (numbers) or symmetric difference (sets).
For numbers.
-----------
This is normal division, but the remainder is discarded.
The result is always an integer.
E.g.
  5432%321
16
  3245.4432%1; // % by 1 effective returns the integer part of a decimal
3245
   frac(x)->x - x%1; // returns fractional part of a number
   frac(5432/432)
0.574074074074074

For sets
--------
  The symmetric difference of two sets is defined as
  A∆B == (A/B)∪(B/a) == (A / B) \/ (B / A)  which is everything
  except the starred area below:

╔═══════════════════════╗
║                       ║   A
║                       ║
║                       ║
║                       ║
║           ╔═══════════╬══════════════════╗
║           ║  *  *  *  ║                  ║
║           ║  *  *  *  ║                  ║
╚═══════════╬═══════════╝                  ║
            ║                              ║
            ║                              ║
            ║                              ║
            ╚══════════════════════════════╝
                         B
E.g.
  {1,2,3}%{2,4,6}
{1,3,4,6}
See also: ∆ (\u2206)
]]>
        </body>
    </entry>
    <entry id="define">
        <body>
 <![CDATA[Keyword.
This denotes a full function definition. Functions definitions are different
from lambdas in that they may contain statements. So for instance, you may
have an if[]then[] in a defined function, but have to use the ternary operator
of boolean?x:y in a lambda definition. Full syntax is

define[
   function_signature
   ][
   » Comments
   body
 ]

Comments will be displayed in system help under

)help name arg_count

N.B. Using the define statement automatically encloses the state of any
variables and other functions so they are not visible. Lambda functions
however access the ambient state. So
   a:=2;
   f(x)->a*x^2;
   f(3)
18
   define[g(x)][return(a*x^2);]
   g(3)
unknown symbol 'a' at (1, 20)]]>
        </body>
    </entry>

    <entry id="~">
        <body>
 <![CDATA[The join operator. This is both monadic and dyadic operates only on lists.

The reason this only operates on lists is that if two stems share a common
index, then it is unclear at all how to decide which to keep. Lists
can, however, always be extended, since it is clear how to make more
indices.

Dyadic operation.
a. ~ b. will append the second list to the first, adjusting indices as needed,
E.g.
  [3;7]~[4;11]
[3,4,5,6,4,5,6,7,8,9,10]
   [;5]~{12:12,{15:15}
[0,1,2,3,4,12,15}

E.g. Operation on higher rank lists
  n(4,5)~n(3,4)
[
  [0,1,2,3,4],
  [0,1,2,3,4],
  [0,1,2,3,4],
  [0,1,2,3,4],
  [0,1,2,3],
  [0,1,2,3],
  [0,1,2,3]
 ]

Monadic operation.
~a. is equivalent to []~a. and has the effect of re-ordering the list
from index 0. This is a very common idiom.
E.g.
  r. := [8,14,-7,16,0];
  r1. := mask(r., r. <= 0)
  r1.
{2:-7,4:0}
  ~r1.
 [-7,0]

E.g. Glom two sparse lists together then re-index them
  ~{2:4,3:5}~{1:7,11:-2}
[4,5,7,-2]

On sets.
--------
To convert a set to a list, use monadic ~. Note that sets have no canonical
ordering, so do check what you get. A set of sets will be returned as a
list of lists.

There is also the laminate function in the extension module for pasting
two stems together along an axis.
See also: ~|, join, copy, insert_at]]>
        </body>
    </entry>
    <entry id="~|" alt="≁">
        <body>
 <![CDATA[Join along last axis. Normal join, ~, operates along the zero-th
axis.
    a. ~| b. == join(a., b., -1)

E.g.
  [;5]~|[10;15]
[0,1,2,3,4,10,11,12,13,14]

Since these are both simple lists, the -1 axis is 0 and
this is the same as using ~. ~| really is for higher rank stems.

E.g. Making a table with headings. Make the table with ~| then stick
     the heading at the top, which must conform to the shape of the
     table.

  [['x','y']]~(n(5,1,[;5])~|n(5,1,[10;15]))
[
  [x,y],
  [0,10],
  [1,11],
  [2,12],
  [3,13],
  [4,14]
 ]

 E.g. A higher rank example. Note that subsetting is in effect, so the
 resulting shape is limited to the smaller (left hand in this case)
 argument. The join is along the last axis still, which is always
 the columns.  So the resulting shape is 3 x 9:
   n(3,4,100+n(12)) ~| n(4,5,n(20))
[
  [100,101,102,103,0,1,2,3,4],
  [104,105,106,107,5,6,7,8,9],
  [108,109,110,111,10,11,12,13,14]
 ]


 See also: ~, join]]>
        </body>
    </entry>
    <entry id="indices">
        <body>
 <![CDATA[indices(args. ,[axis]) - return all the indices for either the entire stem
            or for the given axis. The axis may be signed, so, e.g.
            axis == -1 is the last axis.]]>
        </body>
<example>
<![CDATA[E.g.
    a. := [;5]~n(2,3, n(6))
    a.
[0,1,2,3,4,[0,1,2],[3,4,5]]
    indices(a., 0); // get the first axis
[0,1,2,3,4]
    indices(a., 1); // get the last axis
[[5,0],[5,1],[5,2],[6,0],[6,1],[6,2]]
    a.[6,2]
5

Note that indices(a., 1) == indices(a., -1) in this case.]]>
</example>

    </entry>
    <entry id="transpose" alt="τ">
        <body>
 <![CDATA[Restructure a higher dimension stem by transposing its axes.

transpose(x.) - reverses dim(x.) an remaps the axes of x. If x. is a matrix,
           this is the standard matrix transpose
transpose(x., a) - transforms x. so that the zeroth axis is a.,
             This is equivalent to transpose(x., [a,1,2,...,â,...n])
             where â means the a-th axis is removed. See below
transpose(x., permutation.) - transforms x. as per the permutation.
                    permutation. is a list stem of axes indices.
This does not alter x.  This has no effect on a rank 1 stem (i.e. a simple list).

A few quick examples
  a. := n(2,3,4,5,6,7)
  dim(a.)
[2,3,4,5,6,7]
  dim(transpose(a.))
[7,6,5,4,3,2]
  dim(transpose(a., 2)); // swap axis 2 to 0th position
[4,2,3,5,6,7]
  dim(transpose(a.,[5,0,4,1,3,2]))
[7,2,6,3,5,4]

Note that this intended to operate  on stem lists
of higher dimension and on general stems may lose some of the
entries (of lower dimensionality). The stems do not need all
integer indices, just the same dimension.

E.g. Normally reduce operates on the first axis -- by row.
Compare axis operations on this stem
[
 [1,2,3],
 [5,6,7]
]
Axis 0 operation (default) adds the first row to the second
i.e. add this structure vertically:
    reduce(@+, [[1,2,3],[5,6,7]]);
[6,8,10]
What if we want to add the elements in each row together,
i.e. add horizontally? This is summation on the last axis:
    reduce(@+, transpose([[1,2,3],[5,6,7]],-1));
[
 6,
 18
]

An axis of -1 is always the last axis.]]>
        </body>
    </entry>

    <entry id="greek">
        <body>
 <![CDATA[QDL supports Greek letters for function and variable names.
These are, of course, strictly a matter of taste.
Table of Greek letters with unicode:

\u0391  Α α  \u03b1
\u0392  Β β  \u03b2
\u0393  Γ γ  \u03b3
\u0394  Δ δ  \u03b4
\u0395  Ε ε  \u03b5
\u0396  Ζ ζ  \u03b6
\u0397  Η η  \u03b7
\u0398  Θ θ  \u03b8
          ϑ  \u03d1
\u0399  Ι ι  \u03b9
\u039a  Κ κ  \u03ba
          ϰ  \u03f0
\u039b  Λ λ  \u03bb
\u039c  Μ μ  \u03bc
\u039s  Ν ν  \u03bd
\u039e  Ξ ξ  \u03be
\u039f  Ο ο  \u03bf
\u03a0  Π π  \u03c0
          ϖ  \u03d6
\u03a1  Ρ ρ  \u03c1
          ϱ  \u03f1
\u03a2  Σ ς  \u03c2
          σ  \u03c3
\u03a3  Τ τ  \u03c4
\u03a4  Υ υ  \u03c5
\u03a5  Φ φ  \u03c6
\u03a6  Χ χ  \u03c7
\u03a7  Ψ ψ  \u03c8
\u03a8  Ω ω  \u03c9

Some of these (such as π()) are reserved and have keyboard
shortcuts in ansi mode. There are variants (e.g. ϑ) allowed
precisely because they are standard technical symbols. The intent
is not to allow you to write in Greek, so none of the characters with
diacritical marks, (e.g. ὰ) are here. Strings in QDL support unicode
so you can certainly write Greek inside them:
E.g.
   say('ἀγεωμέτρητος μηδεὶς εἰσίτω')
ἀγεωμέτρητος μηδεὶς εἰσίτω

("Let no one untrained in geometry enter." -- motto of Plato's Academy)

Note ∈ (\u2208) denotes set membership and while derived from epsilon, is
not a greek letter.

See also: unicode]]>
        </body>
    </entry>
    <entry id="ansi_mode">
        <body>
 <![CDATA[(workspace variable)
ansi_mode - (read only) true if QDL is running in ANSI mode.

QDL may be started in ANSI (American Standards National Institute) mode
which allows for command line editing (normally not possible in Java)
and a host of other things. The default terminal for QDL is
the ASCII (American Standard Code for Information Interchange)
terminal, which is very limited but will run everywhere.
ANSI is enabled by specifying the -ansi
switch at the command line. See the details in your distro at

docs\iso6429.pdf

or online at

https://cilogon.github.io/qdl/docs/iso6429.pdf

Note that this does not persist through WS saves. If you are working
in ANSI mode and the system is restarted in ASCII mode, that is
what is available.]]>
        </body>
    </entry>

    <entry id="insert">
        <body>
 <![CDATA[insert(source, snippet, index) - insert the snippet into the source string
     at the given index.

E.g.
    insert('abcd', 'foo', 2)
abfoocd

  insert('abcd', '....', differ_at('abcd','abq'))
ab....cd]]>
        </body>
    </entry>
    <entry id="extrinsic">
        <body>
 <![CDATA["Not part of the essential nature of someone or something; coming
 or operating from outside"

This refers to what are also called global variables in some languages.
These are simply variables prefixed with a single ampersand, &, and are
always available regardless of scope to every module or function.
To list them in the workspace use the -extrinsic command. So in
some worksapce you might be able to do this:

)vars -extrinsic
   &Avogadro  &Planck

   &Planck
6.62607015E-34

None are pre-defined in QDL. You may access extrinsic variables
by simply using them like any other variables (including removing them).
In the final analysis, they are just variables. You should
use them for values that should be global. A variable
like &temp would be a ghastly thing!]]>
            <entry id="&amp;">
                <body>
    <![CDATA[This is the marker for extrinsic variables.

See also: extrinsic]]>
                </body>
            </entry>
        </body>
    </entry>
    <entry id="intrinsic">
        <body>
 <![CDATA["Originating and included wholly within an organ or part."
This refers to variables and functions defined inside a module which are not
visible outside of the module. To mark a function or variable as intrinsic
you prefix the name with a '__' (double underscore).
E.g.
(Inside the body of a module)

__my_password := 'foo';
__f(x)->x^2;

Attempts to access __my_password or __f(x) outside of the module will fail.
Many languages do something similar and refer to these are private elements.

See also: module.]]>
        </body>
    </entry>

    <entry id="private">
        <body>
 <![CDATA[See intrinsic.]]>
        </body>
    </entry>

    <entry id="__">
        <body>
 <![CDATA[Double underscore. Prefix for intrinsic variables and functions in a module
See also: module, intrinsic.]]>
        </body>
    </entry>
    <entry id="ini">
        <body>
 <![CDATA[QDL supports its own initialization file format.
Note that this file format is most emphatically not QDL!
It is quite simple:

section: [section_name]
   line: name (= | :=) entry (,entry)*
  entry: boolean | number | 'string';
comment: (// to end of line ) | (/* anything */)

Such a file has sections enclosed in []'s, (these are not
QDL lists) and each line is an entry, so lines cannot be split.
Entries are standard scalars (booleans, integer,
decimal, scientific notation or strings in single quotes).
Lists are just entries separated by commas. This means that
the entries are typed.

The aim of such a file is for building a possibly sizeable
application with several sections that have their own
configurations. Since bootstrapping such an application can be
hard, you can put the critical information in an ini file,
which can then be read (e.g., by the __init() method of a
workspace). "The bootstrapping problem" refers to how to
start up a system and the easiest way to do it is with
information from outside the system. QDL's ini files are one
way to do this.

The format is easily edited with any text editor
and simple enough that a user with little to no coding
experience and fill in useful information.

Note that while the syntax is sort of like QDL (single quotes
around strings) it is not QDL and you cannot embed code in it.
Also, null is not an allowed value and missing values are
ignored.

On reading, the contents are turned into a stem with sections
as keys and the individuals lines and their contents entered
accordingly, as scalars or lists.

Please see the full documentation either on the website or in the distro

E.g.
[my_app]
/* Example comment */
username := 'bob'
password := 'εΖζΗηΘθϑΙιΚκ'

would be turned into the stem

ini. :=  {'my_app':{'username':'bob', 'password':'εΖζΗηΘθϑΙιΚκ'}}


See also: file_read]]>
        </body>
    </entry>
    <entry id="laminate">
        <body>
 <![CDATA[(extensions module)
laminate(x,y{,axis}) - paste together two conformable stems along the axis.
If axis is omitted, then the operation occurs on the zeroth axis
x - stem or scalar. If a scalar, it will be extended
y - stem or scalar. If a scalar, it will be extended
axis - (option) 0 ≤ axis ≤ max(dim(x),dim(y))
Note: join increases the size of each dimension. laminate increases
      the rank. So if you join a pair of 2x3 arrays you may get back
      a 4x3 or 2x6 (axis 0, 1 resp.)
      Laminate returns the following:
      axis    dim
      0       2x2x3
      1       2x3x3
      2       2x3x2
The rank increases by 1.
axis refers to the new axis. So axis == 0 means to a new axis of zero.
If axis == dim(x.) (e.g. x. is rank 2, axis == 2), then a new last axis
is created.

This function can also augment a smaller stem and paste it to a large (by
rank 1 only) one.]]>
        </body>
<example>
<![CDATA[E.g.
paste together a 2x3 stem to a 2x4x3 along their 1st axis. This means
to treat x. as a 2x1x3 stem and join. Result is a 2x5x3 stem.
   laminate(n(2,3,[;6]),n(2,4,3,[;24]),1);
(output omitted)

E.g.
paste together the following
  x. := n(2,3,[;6]);
  y. := n(2,3,[10;16]);
// paste together along zero-th axis, result is 2x2x3
  laminate(x.,y.); // same as laminate(x.,y.,0)
[
  [
    [0,1,2],
    [3,4,5]
  ],
  [
    [10,11,12],
    [13,14,15]
  ]
 ]

// paste along 1st axis, result is 2x2x3
  laminate(x.,y.,1)
[
  [
    [0,1,2],
    [10,11,12]
  ],
  [
    [3,4,5],
    [13,14,15]
  ]
 ]

// paste along 2nd (last here) axis, result is 2x3x2
  laminate(x.,y.,2)
[
  [
    [0,10],
    [1,11],
    [2,12]
  ],
  [
    [3,13],
    [4,14],
    [5,15]
  ]
 ]

// paste a bunch of zeros on to x. Note that the scalar is extended
// to the same shape as x. beforehand.
laminate(x.,0)
[
  [
    [0,1,2],
    [3,4,5]
  ],
  [
    [0,0,0],
    [0,0,0]
  ]
 ]

]]>
</example>

    </entry>
    <entry id="min">
        <body>
 <![CDATA[min(a,b) - compute the minimum of two numbers or set of stems

See also: max]]>
        </body>
    </entry>
    <entry id="max">
        <body>
 <![CDATA[max(a,b) - compute the minimum of two numbers or set of stems

See also: min]]>
        </body>
    </entry>
    <entry id="chaining">
        <body>
 <![CDATA[Refers to the chaining of comparisons like
   a<b<=c
which is the same as
  (a<b)&&(b<=c)

You may chain any of <, <=,  >, >=,  ==, != or =~.

See comparisons, intrinsic.]]>
        </body>
        <example>
           <![CDATA[E.g.
   k := 0
   while[0<=k<=3][say(k++);]
0
1
2
3

E.g.
   if[2!=x<5][say(sqrt(5-x)/(x-2));];
Meaning that (x!=2)&&(x<5), and if true, say what the value is.]]>
                </example>

    </entry>
    <entry id="ws_macro">
        <body>
 <![CDATA[ws_macro(arg | arg.) - run a set of workspace commands.
arg - a string (possibly with line feeds to separate commands)
arg. - a list of strings to be executed one at a time
output - true if it succeeded, an error if it did not.

This is to be a bridge between QDL and its workspace, if
there is one active. The intent is not to let you write massive
programs (use scripts) but to allow for customization of the
workspace from inside QDL, e.g. in an __init() function,
so the workspace can be initialized etc.
As such, it should be used minimally and with discretion.]]>
        </body>
        <example>
<![CDATA[E.g.
  ws_macro(')ws get');
... prints all current variables
true

   ws_macro([')ws set pp on', ')ws set echo on', ')ws set external_editor nano'])
true]]>
                </example>

    </entry>

    <entry id="cb_exists">
        <body>
 <![CDATA[cb_exists() - boolean valued function to see if the current Java
              environment supports clipboard operations.
              true if supported, false otherwise.

See also: cb_read, cb_write]]>
        </body>
    </entry>
    <entry id="cb_read">
        <body>
 <![CDATA[cb_read() - read the value of the clipboard as a string.
            You must do any conversions you want afterwards.

Note that this will trim any lead/trailing whitespace
since different applications have very different ideas about
that, so it's better to just get rid of it. While we can write
QDL objects to the clipboard, at this point, reading them is
strictly as a string.

E.g.
  cb_read()
mairzy doats

This means that the string 'mairzy doats' was in the clipboard.
See also: cb_exists, cb_write]]>
        </body>
    </entry>
    <entry id="cb_write">
        <body>
 <![CDATA[cb_write(arg | arg.) - write the argument as a string to the clipboard.
               Returns a true if the operation succeeded and
               false otherwise. Note that stems are converted to JSON
               first.

See also: cb_exists, cb_read]]>
        </body>
        <example>
           <![CDATA[   cb_write('mairzy doats')
true

and the line 'mairzy doats' is now in the clipboard.]]>
                </example>

    </entry>

    <entry id="clipboard">
        <body>
 <![CDATA[QDL does support clipboard operations with the provisio that the
system supports them too. This is not always a given. The three main
functions are
cb_exists - boolean function to check if there is a system clipboard
  cb_read - read the current value of the clipboard as a string
 cb_write - write a string to the clipboard

 QDL is restricted to only reading/writing string since other data types
 may be very hard indeed to parse.]]>
        </body>
    </entry>
    <entry id="external_editor">
        <body>
 <![CDATA[(ws variable)
external_editor the name of the editor to invoke for WS edit commands.

    )ws set external_editor nano
external editor was line now is 'nano'

These are set in the configuration, so see the documentation for the
workspace configuration. The line editor is built in and always
available.

See also: ee]]>
        </body>
    </entry>
    <entry id="ee">
        <body>
 <![CDATA[(workspace variable)
Short form of external_editor.

See also: external_editor]]>
        </body>
    </entry>
    <entry id="assertions_on">
        <body>
 <![CDATA[(workspace variable)
Globally toggle assertions on or off. If off, then no
assertions will be active. If assertions are off, then all
assertions will be skipped at runtime. This is also a
configuration option for the workspace.]]>
        </body>
    </entry>
    <entry id="∈">
        <body>
 <![CDATA[Unicode 2208.
x ∈ y - return a left conformable boolean mask of all
   elements of x. that are in y.
   Note that both x and y may be stems.

This may always be replaced by has_value(x,y)

You may use this in loops as well to return either the elements
of a set, or the values of a stem.

See also: ∉, intersection, has_value, subset(@pick arg).]]>
        </body>
        <example>
           <![CDATA[  a. := ['a','b','c']
  b := {'p','q','b','a'};
  a. ∈ b
[true,true,false]
  // Another examples to emphasize that ∈ compares values, not indices.
  [-2,3,4]∈[-3;3]
[true,false,false]
    // This is useful with the mask function.
    mask(a., a. ∈ b)
[a, b]
    // And is fine with loops, so this is a good statement:
    while[α ∈ (A ∩ B) ∆ C][process(α);]
    // In loops over stems (not sets) ∈ operates on the values of a stem
  while[j∈[-3;3]][say(j);]
-3
-2
-1
0
1
2]]>

                </example>
    </entry>
    <entry id="∉">
        <body>
 <![CDATA[Unicode 2209.
x ∉ y - return a left conformable boolean mask of all
   elements of x. that *not* are in y. Note that x may be a stem.

This is equivalent to !has_value(x,y)

See also: ∈, intersection, has_value, subset(@pick arg).]]>
        </body>
        <example>
           <![CDATA[  a. := ['a','b','c']
  b := {'p','q','b','a'}
  a. ∉ b
[false,false,true]

   // This is useful with the mask function.
    mask(a., a. ∉ b)
{2:c}]]>
                </example>

    </entry>
    <entry id="/\" alt="∩">
        <body>
 <![CDATA[Ascii digraph for set intersection. The result is a set
whose elements are common to both arguments.

See also: \/ (set union), subset(@pick arg)]]>
        </body>
        <example>
<![CDATA[    {0,2,3,5} /\ {4,2,1,0}
{0,2}]]>
                </example>

    </entry>
    <entry id="\/" alt="∪">
        <body>
 <![CDATA[Ascii digraph for set union, the result is a set whose
elements are in either of
the arguments.
E.g.
    {0,2,3,5} \/ {4,2,1,0}
{0,1,2,3,4,5}

The difference between ~ and union is that ~ is a list operator and
returns a list, so a~b for two sets returns an error (since they are not
lists). However, monadic ~ will convert a set to a list, which is also
not union!
   ~{3,4}
[3,4]

See also: /\ (set intersection), ~, subset(@pick arg)]]>
        </body>
        <example>
<![CDATA[   {{1,2},{3,4}}\/{{1,2},{'a','b'}}
{{1,2},{a,b},{3,4}}]]>
                </example>

    </entry>


    <entry id="==" alt="≡">
        <body>
 <![CDATA[For scalars, returns a boolean if the values are the same.
Strings must match including case. See =~ (regex matching) as well.

For sets, checks that the elements of one set are identical to
another.

See also: ∈ (has_value), comparisons, subset(@pick arg)]]>
        </body>
        <example>
<![CDATA[  z := |^[;20]*3+2
  z == z
true
   'abcd' == 'Abcd'
false
    2/3 == 2/3
true
   {2,3,4}≡{2,3,5}
false]]>
                </example>

    </entry>
    <entry id="set">
        <body>
 <![CDATA[Often you will just need to do operations on aggregates
of elements  and really don't care about the internal
structure. A set is collection of elements that are
immutable, unique and unordered. Sets are written as elements
between curly braces:

{a,b,c,...}

Operations are intersection, union, difference,
symmetric difference, membership, subsset/superset testing.
Operations on sets return sets or scalars with the exception
of ~ (tilde) which converts a set to a list.

Note that sets have unique elements, so the list [1,1,1,1] (with repeated
elements) will become the set {1} with as single element.

Order of operations on sets is supported as follows:
unions, intersections
differences, symmetric difference
inclusions
membership

E.g. the intersection of two sets
   {1,2,3,4,'a', 'foo'}/\{'a','b',1,3,5}
{1,a,3}

The common elements in more or less random order are returned. If you need
order, consider lists.

Note that in this implementation, intersections and symmetric differences
function as analogs to multiplication and addition of integers, so that
in QDL sets are treated as a elements of a Boolean ring, if you
are aware of such things. This is a more algebraic approach to sets
and works quite well in a programming environment.

Finally, sets may be nested but it is best to keep the elements
as scalars. This is because testing stems for equality (which
can be recursive structures, highly nested etc.) can
be slow and very difficult. On the other hand, sets may
be entries in stems with no issues.

See also: \/, /\, /, %, <, >, ==, ∈, ∉, ~, |=,  pick(@f, arg)]]>
        </body>
    </entry>
    <entry id="local">
        <body>
 <![CDATA[Keyword.
local is a reserved work to denote the beginning of a local environment.
It is set off with []. Anything defined inside it is local only
to that block, and the block *does not* inherit the ambient state.

See also: block, visibility]]>
        </body>
        <example>
<![CDATA[To get values from the local block, use return.
E.g.
  f()->local[r :=5; return(r);]
  f()
5

Let's compare local and block for how they affect the ambient state.

E.g.
   a:= 5;
   local[a :=2;];
   a
5

Compare with
E.g.
   a:= 5;
   block[a :=2;];
   a
2]]>
                </example>
    </entry>
    <entry id="stem">
        <body>
 <![CDATA[An indexed aggregate. Compare with a set, which is an aggregate
with no distinguished way to access elements.
Stems are notated as
variable.
where the final . is the index operator. General stems may be indexed by
pretty much any string or integer. A stem that has only integer indices
is called a list.

Stems are extremely flexible objects and can effectively provide any data
structure you want. Sets are a convenience mostly since emulating sets
with stems is a bit clunky.

See also: slice, set]]>
        </body>
    </entry>
    <entry id="|^" alt="⊢">
            <body>
<![CDATA[Ascii digraph for the operator to convert its argument to a set.

   |^false
{false}]]>
            </body>
        <example>
            <![CDATA[   |^3; // convert a scalar to a set
{3}
   |^[2;7]; // convert the values of a list to a set
{2,3,4,5,6}
   |^{'a':2/3,'b':-3/pi()}; // convert the values of a stem to a set
{0.666666666666666,-0.954929658551372}
   |^keys({'a':2/3,'b':-3/pi()}); // convert the keys of a stem to a set
{a,b}
  ⊢[;5]; // use the other form of the operator
{0,1,2,3,4}]]>
        </example>
        </entry>

    <entry id="overwrite_base_functions">
       <body>
<![CDATA[(WS variable)
This allows for overwriting the base QDL functions. You may always access them
as fully qualified. This means you can use QDL as a library to wrote your own
language.

The downside is speed. Things run a bit slower because native QDL function
resolution is quite fast.
E.g.
   )ws set overwrite_base_functions on
overwrite_base_functions is now on.

    size(x,y)->stem#size(x)+stem#size(y)
    size([;5], [;7])
12
The default is off. In that case, attempting to redefine a base QDL function
throws an error, assuming that you did not mean to do that.]]>
       </body>
    </entry>
    <entry id="sort">
       <body>
  <![CDATA[  sort(arg{,up}) - sort the elements of the argument.
        if up is true (default) the sort is from lowest to highest
        if up is false, the order is descending.
        Always returns a list.

This does sort non-homogenous data and scalars. Since strings and decimals,
say are not comparable really, the result is sorted by type

nulls, booleans, strings numbers, everything else

Notes:
1. mixed data is slower, so if speed is an issue,
keep your data by type.

2. non-scalars are not comparable and are simply stuck together]]>
       </body>
       <example>
<![CDATA[   sort(mod(random(12),17), false); // These are random numbers.
[15,8,4,1,0,0,-3,-5,-8,-8,-9,-10]
    sort([2,6,-1,'a']); // Mixed data
[a,-1,2,6]

    sort([-3/7, 4==5, 'abc', 'SPQR', {3,4,5}]); // Mixed data
[false,SPQR,abc,-0.428571428571428,{3,4,5}]

    sort([-3/7, 4==5, 'abc', 'SPQR', {3,4,5}], false); // redo in descending order
[{3,4,5},-0.428571428571428,abc,SPQR,false]

   sort(2); //scalars are simply returned in a list.
[2]

   // sorting of non-scalars is not well-defined, so sort has no effect
   // on them:
  sort({{1,2},{3,4,5},{2,7}}); // sort set of sets
[{1,2},{2,7},{3,4,5}]
    sort({{1,2},{3,4,5},{2,7}}, false); // reversing the order does nothing
[{1,2},{2,7},{3,4,5}]]]>
        </example>
    </entry>

    <entry id="@" alt="⊗">
       <body>
  <![CDATA[A function reference. Functions may be passed as arguments by reference.
The @ functor (a functor is something that acts on functions).

You may use this on any operator (such as +, *, etc.) or function.

Ways to pass by reference.
Explicitly:
   p(x)->x<4; // boolean valued
   subset(@p, {2,-1,3,5,6})
{-1,2,3}

Implictly:
   subset((x)->x<4, {2,-1,3,5,6})
 {-1,2,3}

In the implicit case, the function is anonymous and the reference is passed.]]>
       </body>
    </entry>
    <entry id="comparisons">
       <body>
  <![CDATA[This encompasses all of the following:
  < <= > >= == !=
Note that each of these operates in various contexts.
Numbers.
These are the standard comparisons.
     2/3 < 3/7
false

Sets.
These are for set inclusion. Note that < and > are strict
   {1,2}<{1,2,3}
true
   {1,2,3}<{1,2,3}
false

Strings.
These test for equality or substring. These are case sensitive tests.
   'doat'<'mairzy doats and dozey doats'
true

You cannot compare stems as aggregates, since these work on the elements:
   [2/3, 'doats', {1,2}] < [3/7, 'mairzy doats', {1,2,3}]
[false,true,true]

each element uses < in a different way, to test as a number, substring and subset.]]>
       </body>
    </entry>
    <entry id="for_lines">
       <body>
  <![CDATA[for_lines(var, file_path) - read lines one at a time.

  This is available only in loops. It is intended for larger files to
  allow line by line processing when reading the entire file into memory
  as a stem or string is too expensive.
  ]]>
       </body>
       <example>
   <![CDATA[This example reads a simple file
     while[for_lines(x, '/tmp/haiku.txt')][say(x);]
From the Cat

In the morning light,
You sleep despite my meow.
I stand on your face.]]>
        </example>
    </entry>
    <entry id="keyboard">
       <body>
<![CDATA[This chart represents a standard US 101 keyboard with added characters
for ANSI mode.
It is done per row so for each row you have

  shift
  alt
base
alt

And each key is separated by |'s

 E.g.
   alt + = yields ≡
   alt + & == alt + shift + 7 yields ∧

  ~ |  ! |  @ |  # |  $ |  % |  ^ |  & |  * |  ( |  ) |  _ |  + |
  ≁ |  ¬ |  ⊗ |    |    |    |    |  ∧ |  × |    |    |    |  ⁺ |
`   |1   |2   |3   |4   |5   |6   |7   |8   |9   |0   |-   |=   |
    |    |    |    |    |    |    |    |    |    |    |¯   |≡   |

  Q |  W |  E  |  R |  T |  Y |  U |  I |  O |  P |  { |  } |  | |
    |    |  ∉  |    |    |    |    |    |    |    |  ⟦ |  ⟧ |  ∨ |
q   |w   |e    |r   |t   |y   |u   |i   |o   |p   |[   |]   |\   |
    |    |∈    |    |τ   |    |∪   |∩   |    |π   |    |   | ≠  |

  A |  S |  D |  F |  G |  H |  J |  K |  L |  : |  " |
    |    |  ∆ |    |    |    |    |    |    |  ≔ |  ≕ |
a   |s   |d   |f   |g   |h   |j   |k   |l   |;   |'   |
⊨   |⊢   |→   |    |    |    |    |⌈   |⌊   |    |    |

  Z |  X |  C |  V |  B |  N |  M |  < |  > |  ? |
    |    |    |    |    |    |    |  ≤ |  ≥ |  ≈ |
z   |x   |c   |v   |b   |n   |m   |,   |.   |/   |
    |    |    |    |    |∅   |    |    |    |    |
See also: unicode, greek]]>
       </body>

    </entry>
    <entry id="list">
       <body>
  <![CDATA[A list is a special type of stem whose keys are integers.
You may create them in various ways using slices or simply enter
the elements directly between square brackets.

See also: stem, slice]]>
       </body>
       <example>
   <![CDATA[   [2,3,-1,5]; //Enter elements
[2,3,-1,5]
    a.:=[-1;4]; // use a slice
    a.
[-1,0,1,2,3]]]>
        </example>
    </entry>
    <entry id="visibility">
       <body>
  <![CDATA[Visibility of variables and functions is managed in several ways.
The initial state that QDL starts in is the ambient space. All other states
inherit from that unless otherwise stated. Block statements (local, block
keywords) allow you to manage state.

Why have these? Because you may want to keep state very separate.
Consider the case that you are writing a library of functions.
You would want all the internal workings separate from the ambient
environment so that the user does not have their variables and other
functions redefined seemingly at random.

Functions should be easily available but there is a collision with
Church's Lambda Calculus ("everything is a function!") with the
reality of state management on a computer. So we have the define keyword
which is more computer sciencey and is what you normally want when
writing libraries (and include auto documentation)and lambda
expressions (with a ->) for on the fly function defintions.

Global variables are prefaced with a & and are always available,
and should be used for truly global things.

The define keyword.
This restricts visibility to only imported modules

These are defined to illustrate the examples.
  a := 4;
  s(x)->x^2
  &my_global := 5;

  define[f(x)][return(a*x);]
  f(2)
unknown symbol 'a' at (1, 20)

but global variables are always there

  define[g(x)][return(&my_global*x);]
  f(2)
10

Lambdas.
Using lambdas there is a hierarchy for blocks

 local  - only arguments passed in are visible
  block - ambient is visible, but new definitions stay local
ambient - new functions and variables are available everywhere

Local block examples. This gives the least visibility of all the options

  h(@f, x)->local[return(f(x));]
  h(@s, 2)
4

  hh(@f, x)->local[return(&my_global*f(x));]
  hh(@s, 3)
45

Block examples. A block statement with a lambda gives more visibility
than a define statement.

   b(@f, x)->block[y:=x/2;return(a*y);]
   b(@s, 3)
6
   is_defined(y)
false

Lambdas have the same state as an block statement, so
  zz(x)->y:=x^2;
  zz(4)
16
  is_defined(y)
false]]>
       </body>
       <example>
   <![CDATA[   f(x,y,z) -> block[q:=x; q:=q+y ; q:= q+z ; return(q);];
   f(3,2,1)
6]]>
        </example>
    </entry>
    <entry id="is_null">
       <body>
  <![CDATA[is_null(arg) - returns true if the argument is null, false otherwise.

  A common construction is to set a variable null, e.g.
     a. := null;
Testing  a. == null later works unless a. has had a value assigned, in which case each
element is tested for equality.

     a. == null
true;
    is_null(a.)
true;
   a.0 :=1;
   a. == null;
[false]
   is_null(a.)
false

Note that in the last case, is_null returns true if the entire argument is null.]]>
       </body>
       <example>
   <![CDATA[
   ]]>
        </example>
    </entry>
    <entry id="gcd">
       <body>
  <![CDATA[gcd(x,y) - returns the greatest common divisor of x and y

  gcd(720, 1800)
360

See also: lcm]]>
       </body>
    </entry>
    <entry id="lcm">
       <body>
  <![CDATA[lcm(x,y) - the least common multiple of x and y
  lcm(720, 1800)
3600

Note that lcm(α,β)=α×β÷gcd(α,β)

See also: gcd]]>
       </body>
    </entry>
    <entry id="&lt;&lt;">
       <body>
  <![CDATA[A << B - check if A is of type B.
Read 'A is a B'
Supported types built in to QDL:
Null
Boolean
String
Integer
Decimal
Number
Stem
Set
List

The result is always a boolean.
Note that this is applied to the left hand side, so [1,2,3] << List would not check each element.
This means that the << operator is something of an exception to the usual operator.]]>
       </body>
       <example>
   <![CDATA[  4 << Number
true
  4 << Decimal
false;
  [;5] << List
true]]>
        </example>
    </entry>
    <entry id="»">
       <body>
  <![CDATA[unicode \u00bb.
  This is the marker for module or function documentation. The general format is
define[
  signature
  ][
  » first line
  » second line...
  body
  ];
When listing the function (or module) the first line will be spit out as a
short form, so make sure it says something useful. The rest of the lines are printed.
Note that only the initial block of these is parsed, so any documemntation lines
outside of this are ignored.]]>
       </body>
       <example>
   <![CDATA[E.g. of how the help system works, This has to be in a file or buffer.
since it has to span several lines:

  define[
    f(x)
  ][
    » f(x) returns the square of x
    » x can be a stem too.
    return(x^2);
  ];

//If you issue
   )help *
f(x) returns the square of x

(along with possibly a ton of other first lines from module functions)

  )help f 1
f(x) returns the square of x
x can be a stem too.]]>
        </example>
    </entry>
    <entry id="m_set">
       <body>
  <![CDATA[(in the extension module)
m_set(a., keys., values) - set multiple values
   keys. - a list of multi-indices
   values - either a scalar or stem of new values in
            1 - 1 correspondence with the keys.
   Note that this alters a. and also returns it
   See also: m_indices
  ]]>
       </body>
       <example>
   <![CDATA[    a. := n(5,5,n(25))
    m_set(a., [[0,0],[1,1],[2,2],[3,3],[4,4]], ['a','b','c','d','e'])
[[a,1,2,3,4],[5,b,7,8,9],[10,11,c,13,14],[15,16,17,d,19],[20,21,22,23,e]]
    m_set(a., [[0,0],[1,1],[2,2],[3,3],[4,4]], -1); // scalar multi-set
[[-1,1,2,3,4],[5,-1,7,8,9],[10,11,-1,13,14],[15,16,17,-1,19],[20,21,22,23,-1]]
    m_set(a., m_indices([;5],2), -5); // set column 2 to -5 (formatted for view)
[
 [-1,  1, -5,  3,  4],
 [ 5, -1, -5,  8,  9],
 [10, 11, -5, 13, 14],
 [15, 16, -5, -1, 19],
 [20, 21, -5, 23, -1]
]
      b.:=  m_set(n(5,5,[0]), m_indices([;5],-1), 1); // set last column to 1
      b.
[[0,0,0,0,1],[0,0,0,0,1],[0,0,0,0,1],[0,0,0,0,1],[0,0,0,0,1]]]]>
        </example>
    </entry>
    <entry id="\">
       <body>
  <![CDATA[\ is the subset operator for stems. This allows you to
extract part of a stem.

var ((\ scalar | stem | *) | (\! scalar | stem | *))+


 \! (uniqueness) will force the resulting stem to have exactly the
    indices of that dimension,
 \  for integers, they will be re-ordered. String keys are, however, never altered.
 * means to take all of the indices for that dimension.
 scalar indicates to use that for accessing the value, but do not include it in the final result.

 E.g.
   a.:=n(5,5,n(25)); // 5 x 5 stem
   a\1\[1,3];
[6,8]

The result is [a.1.1, a.1.3] note that the scalar in the first dimension omits it. giving a list.

   a\![1]\[1,3]
{1:[6,8]}
The ! means that the first dimension must preserve the index 1.

   a\[1]\[1,3]
[[6,8]]
No ! means that the system should re-index.
  ]]>
       </body>
       <example>
   <![CDATA[Let us say you read in a large JSON object which had a structure like
z.content.clients.i.transactions.j.user_uid
You could simply get all of the clients and user ids for the 0th transactions with

   z\'content'\'clients'\*\'transactions'\0\'user_uid'
[tom@bsu.edu,dick@bsu.edu,harry@bsu.edu]

Note that this returns a subset that is independant of the original stem
hence the values are copied.
   ]]>
        </example>
    </entry>
    <entry id="\>">
       <body>
  <![CDATA[Extraction using a simple list of elements. Each element of the list
is treated like an argument. In essence, in this context > distrubutes \
to each element of the list

var ((\> stem)  | (\!> stem ))+

think of > as an operator in this context which means to distribute the \ to
each element  of the stem argument.

E.g.
a\p\q\r\t == a\>[p,q,r,t]

One caveat is that with \, like the stem reference operator ., you may
supply unknown variables which will be replaced with their constant values.
So
a\b == a\'b'

if and only if b is undefined, otherwise b's value is substituted. However
with \>, the system evaluates the list before handing it over, so this is
not possible and all list elements must be resolvable.
  See \, star()
  ]]>
       </body>
    </entry>
    <entry id="star">
       <body>
  <![CDATA[star() is a functional analog of the wildcard or * operator
in extractions. That assumes the full set of indices in context.
a\* == a\star()

This is most useful if you are constructing an argument for extraction, e.g.
  a.:=n(3,4,n(12))
  a\>(1~(size(a.)<4?star():[2,4]))
[4,5,6,7]

Note that this creates (in this case) the expression a\>[1,*] meaning go to the first element,
return everything. Compare with say
   a\>[2,[1,3]]
[9,11]]]>
       </body>
    </entry>

    <!--
        entry template
    -->
    <!--
    <entry id="">
       <body>
  <![CDATA[
  ]]>
       </body>
       <example>
   <![CDATA[
   ]]>
        </example>
    </entry>
          -->
</help>

                                      
