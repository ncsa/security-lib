<help>
    <entry id="abs">
        <body>
            <![CDATA[
abs(arg) - find the absolute value of a number or stem.
E.g. abs(-2) yields 2.
            ]]>
        </body>
    </entry>
    <!-- NOTE no blank elements -->
    <entry id="date_ms">
        <body>
            <![CDATA[
   date_ms() - current date in milliseconds
date_ms(arg) - if arg is an integer, return it, if it is a string
               in ISO 8601 format.
See also: date_iso
            ]]>
        </body>
    </entry>
    <entry id="date_iso">
        <body>
            <![CDATA[
   date_iso() - return the current date as an ISO 8601 formatted string
date_iso(arg) - if arg is an integer, convert it to an ISO string.
                If it is an ISO string, return it.
See also: date_ms
            ]]>
        </body>
    </entry>

    <entry id="decode_b64">
        <body>
            <![CDATA[
decode_b64(arg) - decode a base 64 encoded string or stem of strings to string(s).
                  Note that if the arg is encoded binary, you will get
                  gibberish back.
See also: encode_b64
            ]]>
        </body>
    </entry>

    <entry id="encode_b64">
        <body>
            <![CDATA[
encode_b64(arg) - encode a string or stem of string into base 64.
We follow RFC 4648, meaning that the result is not padded with
things like ='s, and the character set is a-zA-Z0-9-_.
This makes the result always URL safe.
Full technical description: https://datatracker.ietf.org/doc/html/rfc4648
See also: decode_b64
                ]]>
        </body>
    </entry>

    <entry id="head">
        <body>
            <![CDATA[
head(target, delim[,is_regex]) - Return up to delim in the
                 target. Both of the first arguments
                 may be conformable stems. The result is always conformable to
                 target.
                 is_regex - if true splits using the second as a regex.
E.g.
    head(['bob@foo', 'todd@foo', 'rolf!baz'], '@')
[bob,todd,]

Note that there is no match for the last element, so an empty string is
returned.
Equivalent to tokenize(target, delim, is_regex).0
See also: tail
                ]]>
        </body>
    </entry>
    <entry id="tail">
        <body>
            <![CDATA[
tail(target, delim[,is_regex]) - Return from after the last
                 delim in the target to the end of the string.
                 Both of the first arguments may be conformable stems.
                 The result is always conformable to target.
                 is_regex - if true treats the second argument as
                 a regular expression
E.g.
      tail(['bob@psu.edu', 'todd@bsu.edi', 'rolf!baz'], '@')
[psu.edu,bsu.edi,]

Note that there is no match for the last element, so an empty string is
returned.

      tail('a d, m,\ti.n','\\s+', true);    // uses whitespace
i.n

This is equivalent to returning tokenize(a,b,is_regex).(-1);
See also: head
                ]]>
        </body>
    </entry>

    <entry id="from_hex">
        <body>
            <![CDATA[
from_hex(arg) - convert a hexadecimal string or stem of strings to a string.
See also: to_hex
                ]]>
        </body>
    </entry>
    <entry id="check_syntax">
        <body>
            <![CDATA[
check_syntax(string) - This will take the (possibly very long) string and run
                       it through the parser checking for syntax errors. Note
                       that this does not run anything! Its use is to help
                       you track down errors like missing semi-colons, illegal
                       characters and other statements. It returns either an
                       empty string (no issues found) or an error message
                       containing something like 'syntax error: line 1:4'.
                       This means that the first line of input (lines are
                       counted starting at 1) had an error at position 4
                       (characters on the line are counted from zero).
E.g.
   check_syntax(file_read('/path/to/file/x.qdl'))
syntax error:line 11:27 mismatched input '=' expecting {'^', '=<', '=>', ...

Meaning that on line 11, position 27 there was an error in the file.
See also: execute
]]>
        </body>
    </entry>
    <entry id="hash">
        <body>
            <![CDATA[
hash(arg) - calculates the SHA-1 digest of a string or stem of strings.
            The output is a hexadecimal string. Note that this has nothing to
            do with converting to or from hex strings.
                ]]>
        </body>
    </entry>
    <entry id="mod">
        <body>
            <![CDATA[
mod(a,b) - compute the modulus, i.e., the remainder after long division, of two
           integers. The arguments are either scalar or stems.
                ]]>
        </body>
    </entry>
    <entry id="numeric_digits">
        <body>
            <![CDATA[
   numeric_digits() - display the current precision
numeric_digits(arg) - set the precision to the value of arg, which is a
                      positive integer.
                      The result displayed is the old precision.
Note: Precision refers to the total number of digits that are considered
      accurate. So if the precision is 5, the number 4321.12345 is actually
      only accurate to 4321.1 and anything after that is an artifact of
      approximation. QDL will show values as accurately as possible,
      so if the value were 1.00000009 then QDL would display 1 as the
      value, since up to precision, they are the same.
      See the reference manual for a more information.
                ]]>
        </body>
    </entry>
    <entry id="random">
        <body>
            <![CDATA[
 random() - return a random number
random(n) - return n (an integer) random numbers as a stem list.
                ]]>
        </body>
    </entry>
    <entry id="random_string">
        <body>
            <![CDATA[
    random_string() - return a random string of 16 bytes, base 64 encoded.
   random_string(n) - return a random string of n bytes, base 64 encoded
random_string(n, m) - return a list containing m entries with n bytes each,
                      base 64 encoded
See also: encode_b64, decode_b64
                ]]>
        </body>
    </entry>
    <entry id="to_hex">
        <body>
            <![CDATA[
to_hex(arg) - convert a string or stem of strings to hexadecimal numbers.
              Note: Since the representation relies on the underlying character
              set, this is of less use generally than encoding a string in
              base 64. However, from_hex is guaranteed to be its inverse.
See also: encode_b64, decode_b64, from_hex
                ]]>
        </body>
    </entry>
    <entry id="box">
        <body>
            <![CDATA[
box(arg0, arg1, ...) - take any collection of variables and turn them into a
                       single stem, their names becoming keys. They are removed
                       from the symbol table. There must be at least one
                       argument and the result is a boolean true if it
                       succeeded and false otherwise (so you can test
                       programatically if it worked).
See also: unbox
                ]]>
        </body>
    </entry>
    <entry id="exclude_keys">
        <body>
            <![CDATA[
exclude_keys(target., list.) - remove the list. of keys (and their values) from
                               target.
E.g.
  exclude_keys([2,4,6,8],[1,2])
{0:2,3:8}

Note: The result will be a subset of target. that contains none of the keys
      listed in the list. argument.
                ]]>
        </body>
    </entry>
    <entry id="from_json">
        <body>
            <![CDATA[
         from_json(arg) - takes the argument with is a string representation of
                          JSON and turns it into a stem.
from_json(arg, convert) - as per single argument case, but allows a flag (true
                          or false) if vencode is to be applied to each key.
                          The default is false.
See also: vencode, to_json
                ]]>
        </body>
    </entry>
    <entry id="list_keys">
        <body>
            <![CDATA[
list_keys(arg.) - returns a list of the keys in the argument.
list_keys(arg., boolean) - returns a list of the keys in the argument.
                           which is a boolean that when true will
                           return only those keys whose values are
                           scalars. if false, stem keys are returned.
list_keys(arg., var_type)- returns a list of the keys in the argument.
                           for the given type (which is an integer).

Note: Strings are scalars.
See also: keys(), var_type(), constants('var_type')
                ]]>
        </body>
    </entry>
    <entry id="has_keys">
        <body>
            <![CDATA[
has_keys(target., key_list.) - returns a boolean list that is the same size as
                               key_list. and has a true or false if that entry
                               is a key in target.
See also: list_keys
                ]]>
        </body>
    </entry>
    <entry id="include_keys">
        <body>
            <![CDATA[
include_keys(target., key_list.) - returns a stem that is the subset of target,
                                   including only keys found in key_list.
E.g.
  include_keys([2,4,6,8],[1,2])
{1:4,2:6}

See also: exclude_keys
                 ]]>
        </body>
    </entry>
    <entry id="n">
        <body>
            <![CDATA[
n(n0,n1,...[, values.]) - make a stem list whose values are 0,..., n-1
Note: This is extremely useful in certain looping constructs.
See also: shuffle(n) which also creates the same list of integers, but in
          random order.
A nickname for this function is n().
                 ]]>
        </body>
    </entry>

    <entry id="identity">
        <body>
            <![CDATA[
identity(x) - return x unchanged. This is useful for instance if you
              need a function to express a value rather than just the
              value itself.
A nickname for this function is i().
                 ]]>
        </body>
    </entry>
    <entry id="input_form">
        <body>
            <![CDATA[
   input_form(module) - The argument is a string with the name of the module
                        or one of its aliases.
 input_form(variable) - The argument is a variable (not a string)
input_form(f, arg_ct) - The arguments are a function (not a string) and the
                        number of arguments.
See also: execute();
                 ]]>
        </body>
    </entry>
    <entry id="has_value">
        <body>
            <![CDATA[
has_value(left_arg, right_arg) - returns a boolean result conformable to the
         left_arg (so a scalar left arg returns a scalar, but a stem returns
         a stem). This checks the the value of the left_arg is in the
         right_arg. Note that unlike many other stem functions, the keys are
         ignored. The resulting key set will always be identical
         to the left_arg.
See also: mask
            ]]>
        </body>
    </entry>
    <entry id="is_list">
        <body>
            <![CDATA[
is_list(stem.) - returns a true if the stem. is a list, i.e., the only keys are
                 integers.
                 ]]>
        </body>
    </entry>
    <entry id="keys">
        <body>
            <![CDATA[
keys(arg.) - returns a stem of all the keys in arg. Every key is returned and
             the value is just the key itself
keys(arg., boolean) - returns a stem of the keys in the argument.
                      If the boolean is true will return only those keys whose
                      values are scalars. if false, stem keys are returned.
keys(arg., var_type)- returns a stem of the keys in the argument.
                      for the given type (which is an integer).
This is extremely useful
in conjunction with the rename_keys() call.
If you supply and integer for the variable type, only
Note: There is no canonical ordering of keys, so these are effectively random.
See also: list_keys(), rename_keys(), var_type(), constants('var_type')
                 ]]>
        </body>
    </entry>
<!--    <entry id="append">
        <body>
            <![CDATA[
append(list0., arg) - append arg to list0., adjusting the indices as
                           needed.
Note: If arg is a scalar, the single value is appended. If arg is a list,
      then the entire list is appended.
                 ]]>
        </body>
    </entry>-->
    <entry id="copy">
        <body>
            <![CDATA[
copy(source., start_index, length, target., target_index) -
               copy one list into another, overwriting old elements.

     source. = the stem that is the source of the copy.
 start_index = the index in the source where the copy starts
      length = how many elements to copy
     target. = the target stem of the copy
target_index = the index in the target that will receive the copy. Note that
               any elements already in these locations will be replaced. If you
               need to insert elements, consider using the insert_at
               command.
See also: insert_at
                 ]]>
        </body>
    </entry>
    <entry id="insert_at">
        <body>
            <![CDATA[
insert_at(source., start_index, length, target., target_index) -
               insert one list in another, moving the old elements.

     source. = the stem that is the source of the copy.
 start_index = the index in the source where the copy starts
      length = how many elements to copy
     target. = the target stem of the copy
target_index = the index in the target that will receive the copy. Note that
               any elements already in these locations will be moved. If you
               intend to replace a section of this list, consider using the
               copy command.
            See also: copy
]]>
        </body>
    </entry>
    <entry id="remap">
            <body>
                <![CDATA[
Take the elements in arg. and create a new stem. There are two cases:

remap(source_list., index_list.) - returns the elements of source_list.
          as specified in index_list. The result is always a simple list.

The contract runs as follows. If
   index_list. := {k0:v0, k1:v1, ..., kn:vn}
then the result, r., satisfies
  r.kj := source_list.vj;

E.g. Show basic contract
    r. := remap(3*[;10], 2*[;5]+1)
    r.
[3,9,15,21,27]

Note that
  source_list. := [0,3,6,9,12,15,18,21,24,27]
   index_list. == [1,3,5,7,9]
                   0 1 2 3 4 <-- indices in the list
  r.0 := source_list.1
  r.1 := source_list.3
  r.2 := source_list.5
  r.3 := source_list.7
  r.4 := source_list.9


E.g: Turn an array into a flat list
   a. := [;5]
   a.'foo' := 'bar'
  remap(a., indices(a.))
[bar,0,1,2,3,4,5,6,7,8,9,10,11]

E.g. Remapping the result to a non-list stem
   r. := remap(3*[;15], {'foo':3,'bar':5,'baz':7})
   r.
{bar:15, foo:9, baz:21}

 Note that
   r.'foo' := source_list.3
   r.'bar' := source_list.5
   r.'baz' := source_list.7

Most general case
remap(source_list., old_indices., new_indices) - returns the elements of source_list.
          as specified by (assuming out. is the returned result)

          out.new_indices.i := source_list.old_indices.i

This permits a very general remapping of any stem to any other stem,
where new_indices. determines the resulting shape. Remember that
*_indices. are lists in 1 to 1 correspondence.

E.g. Using stem indices on higher rank arguments
Remember that for a stem a.,
   a.[p,q] == a.p.q
This lets you select a subset like so:
   a. := n(3,4,n(12))
   r. := remap(a., [[0,1],[1,1],[2,3]])
   r.
[1,5,11]

And
    r.0 := a.[0,1]
    r.1 := a.[1,1]
    r.2 := a.[2,3]

Yes, you can use arbitrary indices to so
   remap(a., {'foo':[0,1],'bar':[1,1], 'baz':[2,3]})
{bar:5, foo:1, baz:11}

is fine, though, of course, in the general case of stems, there is no
canonical ordering of keys...

Note: If you need to re-roll one array (e.g.) into another, the right way to
do it is using the n function:
   n(2,2, remap(a., [[0,1],[1,1],[2,3],[2,0]]))
[[1,5],[11,8]]

It is vastly easier to do it this way than have some extremely complex remapping
scheme for higher rank stems. You get back a (more or less) linear structure
you can then recast as needed.

Example: General case, getting the transpose of a stem.
In linear algebra, a matrix A[i,j] is the transpose of B[i,j] if
  A[i,j] = B[j,i]
I.e., the term on the left has the indices swapped.
In QDL, this is done by reversing each of the indices
So if our stem is
      a. := n(3,5,n(15))
      say(a., true)
      [
        [0,1,2,3,4],
        [5,6,7,8,9],
        [10,11,12,13,14]
       ]
Then we need to reverse all the old indices (that means indices for the last
axis), and we reverse each of them for the new indices.
  old. := indices(a.,-1)
  new. := for_each(@reverse,  old.)
So to get the transpose,
   b. := remap(a., old., new.)
   say(b., true)
[
  [0,5,10],
  [1,6,11],
  [2,7,12],
  [3,8,13],
  [4,9,14]
 ]

 Note that this works on any  higher order stems as well.
 See also: transpose, n (function), rename_keys
                ]]>
            </body>
        </entry>
    <entry id="subset">
        <body>
            <![CDATA[
Function to extract a subset. Note that the result is *always*
a rank 1 stem and it operates only on the zeroth axis.

subset(source_list., start_index) -
          return a subset of the source_list starting at the given index.
subset(source_list., start_index, n) -
          return a subset of the source_list starting at the given index,
          but only return n elements.
Note: If n is omitted, then the rest of the list is returned from the start
      index on. The source is not altered and the resulting list has 0 as
      its first index.

See also: n()
]]>
        </body>
    </entry>
    <entry id="mask">
        <body>
            <![CDATA[
mask(target., bit_mask.) - returns a subset of target. corresponding to each
                           true value in the mask.
Note: This operates generally on stems. Many operations return boolean stems
      which can be used with this function.
E.g.
Make a random list of numbers and get the negative then positive ones.
Do note that the indices are not re-ordered (since mask applies to
generic stems and that would be bad).

  r. := mod(random(5),97)
  r.
[-93,77,56,-46,67]
  mask(r., r. < 0)
{0:-93,3:-46}

  mask(r., r. > 0)
{1:77,2:56,4:67}
               ]]>
        </body>
    </entry>
    <entry id="rename_keys">
        <body>
            <![CDATA[
rename_keys(target., new_names.) - rename the keys in target. using new_names.
           new_names. is stem of the form
              {old0:new0, old1:new1,...}
           where old* are the current names of the keys in target.
           and new* are the new names
           target.old_j is replaces with target.new_j but unspecified entries
           are not changed.
           Modifies target., returns the modified target.

This function has relatively simple syntax and is a common idiom.

E.g. Keys have a common prefix of 'x_' Remove the prefix.
    a. := {'x_x':'A','x_y':'B'};
    rename_keys(a., keys(a.)-'x_');
{x:A,y:B}

Note that a. has been altered.
Remap can do something similar, but the arguments are different since they are
lists. To repeat the above example using remap:

    b. := {'x_x':'A','x_y':'B'};
    remap(b.,list_keys(b.), list_keys(b.)-'x_')

Note b. would not be changed.

See also: remap
                ]]>
        </body>
    </entry>

    <entry id="set_default">
        <body>
            <![CDATA[
set_default(stem., scalar) - sets the default value for this stem to the value
                             of scalar.
Note: The default value is not returned in any key operations, so setting the
      default for a new stem and using the keys() function on it returns an
      empty list, for instance.
                ]]>
        </body>
    </entry>
    <entry id="size">
        <body>
            <![CDATA[
size(arg) -  return the size of the argument.

arg is a stem - return the number of elements in the stem
arg is a string - return the number of characters in the string, i.e., its
                length
args is a scalar - zero, since scalars (such as integers) have no size.
            ]]>
        </body>
    </entry>
    <entry id="to_json">
        <body>
            <![CDATA[
                 to_json(stem.) - convert the stem to a JSON string.
        to_json(stem., convert) - if convert is true, vencode all keys in the
                                  JSON for the stem
to_json(stem., convert, indent) - (requires convert), indent is an integer
                                  giving the number ofspaces to indent the
                                  JSON string
See also: from_json
                ]]>
        </body>
    </entry>
<!--    <entry id="to_list">
        <body>
            <![CDATA[
to_list(arg0, arg1, ...) - takes any set of arguments (including stems) and
                  converts to a list, whose elements are the arguments.
Note: This does not remove the arguments from the symbol table.
                ]]>
        </body>
    </entry>-->
    <entry id="unbox">
        <body>
            <![CDATA[
unbox(arg. [, safeModeOn]) - takes the argument (a stem) and turns each element
                             by (non-integer) key into a variable.
                             safeModeOn (default is true) will NOT overwrite
                             any variables in the current workspace, AND it will
                             vencode any keys needed. Turning
                             safeModeOn to false will fail if a variable exists or
                             if unboxing would result in an illegal varaible name.
E.g.
   a :='f(x)';
   x.a := 2; // perfectly legal
   x.
{f(x):2}
   unbox(x.)
   )vars
f$28x$29

because 'f(x)' cannot be a legal variable name so it was vencoded.
See also: box, vencode, vdecode
                ]]>
        </body>
    </entry>

    <entry id="to_uri">
        <body>
            <![CDATA[
to_uri(string) - Takes a string that is a valid URI and returns a stem variable
                 with all the parts (scheme, query, etc.) put into entries.
                 This is RFC 3986 compliant.
See also: constants() for the field names, from_uri.
]]>
        </body>
    </entry>

    <entry id="from_uri">
        <body>
            <![CDATA[
from_uri(stem.) - Turn a stem into a uri. Typically if you have a uri in the
                  variable x, then
   x == from_uri(to_uri(x))
should be true.
See also: constants() for the field names, to_uri.

                ]]>
        </body>
    </entry>
    <entry id="unique">
        <body>
            <![CDATA[
unique(list.) - Take a stem and return a list of the unique elements.

E.g.
  unique(['a',2,4,true]~[[['a','b',0,3,true]]])
[0,a,2,b,3,4,true]

This may be used on any stem. There is never any implied order.
                ]]>
        </body>
    </entry>
    <entry id="halt">
        <body>
            <![CDATA[
  halt([message]]) - This will halt the system on this line and update the
                     workspace state indicator, passing along the message.
                     Note that this is properly a debugging tool.
                     This is disabled in server mode.
]]>
        </body>
    </entry>
    <entry id="union">
        <body>
            <![CDATA[
union(arg0., arg1., ...) - takes the union of all stems, returning a single
                           stem all of whose keys-values are taken form the
                           arguments. Note that the stems are processed in
                           order and values may be over-written.
                ]]>
        </body>
    </entry>
    <entry id="dir">
        <body>
            <![CDATA[
dir(arg) - list the names of the files in a given location. Note that this
           is VFS aware.
Note: Directory names will have a / appended to them. Also, if the directory is
empty, the result will be an empty list. If the arg is not a directory, then
the result is null.
           ]]>
        </body>
    </entry>
    <entry id="mkdir">
        <body>
            <![CDATA[
mkdir(arg) - make a directory. Note that if there are path components that do
             not exist, they will be created. This returns true if it worked.
Note: One major reason for this to fail is that, e.g., a virtual file system
      is mounted in read only mode.
]]>
        </body>
    </entry>
    <entry id="rmdir">
        <body>
            <![CDATA[
rmdir(path) - remove the last component of this path (which must be a
              directory).
Note that the directory must be empty first.
See also: rm - remove a single file
]]>
        </body>
    </entry>
    <entry id="rm">
        <body>
            <![CDATA[
rm(file_name) - removes the given file.
             ]]>
        </body>
    </entry>

    <entry id="say">
        <body>
            <![CDATA[
say(arg) - print anything.
say(arg, pretty_print) - print anything, but make the format more vertical if
                         its a stem.
Note: say returns the value of its argument so this can be used in statements
for debugging too.
See also: print
]]>
        </body>
    </entry>
    <entry id="print">
        <body>
            <![CDATA[
print - this is a synonym for the say function, so read the help for that.
                ]]>
        </body>
    </entry>
    <entry id="file_read">
        <body>
            <![CDATA[
file_read(file_name) - read a file in. The result is a single string of the
                       file contents
file_read(file_name, type) - type is an integer that determines the result:
-1 = as string (default)
 0 = binary. This reads the file and hands back a single base 64 encoded
     string of the contents.
 1 = stem. A stem list whose entries are each line in the file.
See also: decode_64
]]>
        </body>
    </entry>
    <entry id="scan">
        <body>
            <![CDATA[
scan([prompt]) - get user input. The prompt is optional, but will be printed.
                 Input from the console blocks until
                 the user hits enter.
                ]]>
        </body>
    </entry>
    <entry id="vfs_mount">
        <body>
            <![CDATA[
vfs_mount(cfg.) - mount a virtual file system.
Note: The cfg. contains the cf"dironfiguration and is not trivial to describe.
      Read the reference manual for the details.

E.g. mounting an in-memory VFS

   cfg.type :='memory';
   cfg.scheme := 'ram-disk';
   cfg.mount_point := '/vfs/cache';
   cfg.access := 'rw';
   vfs_mount(cfg.);
true

Now you can issue commands like
   file_write('ram-disk:#/vfs/cache/readme.txt', readme.);

This will write the value of the variable readme. to the
file readme.txt in the VFS.

You can mount VFS's when starting the workspace. See the configuration
reference manual for details.
Alias: io#mount
See also: vfs_unmount
             ]]>
        </body>
    </entry>
    <entry id="vfs_unmount">
            <body>
                <![CDATA[
vfs_unmount(mount_point) - unmount the file system at the given mount_point

This does nothing to the mounted file system, it simply makes it inaccessible
in the current environment. If the mount_point is invalid, an error is raised.
Otherwise, a true is returned.
E.g.
   vfs_unmount('vfs#/mysql/')
true

The file system mounted at vfs#/mysql/ is now no longer accessible and any
operations against it will fail henceforth, e.g.
   dir('vfs#/mysql/')
null

Alias: io#unmount
See also: vfs_mount
                ]]>
            </body>
        </entry>


    <entry id="file_write">
        <body>
            <![CDATA[
file_write(file_name, contents) = write the contents to the given file.
                                  contents can be a string or a list of strings
file_write(file_name, contents, is_base_64) = same, but if is_base_64 is true,
                                  then the contents are decoded to binary
                                  before writing. The default is that this
                                  flag is false.
See also: file_read, decode_b64, encode_b64
]]>
        </body>
    </entry>
    <entry id="starts_with">
        <body>
            <![CDATA[
starts_with(x., y.) - returns a left conformable list that has the
                           indices of the right argument.  If there
                           is no such element, an index of -1 is returned.
E.g.
  starts_with(['a','qrs','pqr'],['a','p','s','t'])
{0=0, 1=-1, 2=1}
How to read this: left element 0 starts with right element 0
                   "     "     1  does not start with any
                   "     "     2 starts with right element 1

To get a list of these, use mask, e.g.
     mask(['a','qrs','pqr'], -1 <starts_with(
                                 ['a','qrs','pqr'],
                                 ['a','p','s','t']));
{0=a, 2=pqr}
See also: mask
               ]]>
        </body>
    </entry>

    <entry id="shuffle">
        <body>
            <![CDATA[
shuffle(n) - n is a positive integer, shuffle the first n integers randomly
shuffle(target., keys.) - shuffle (i.e., permute) the keys in the target.
                          according to keys.
                          Argument keys. must have the same keys as the target.
                          AND the values of keys. are (as a set) the same as
                          the keys. in the target.
E.g.
   shuffle(7)
[5,0,4,6,1,2,3]
Note that if you run this example, the result will be very probably be
different since the result is random.

E.g.
    shuffle(2+3*indices(4), [2,1,3,0])
[8,5,11,2]

     In this case, the left argument is [2,5,8,11] and the right argument
     has 0->2, 1->1, 2->3, 3->0. This works generally with stems too.
See also: indices, rename_keys, which lets you rename some of the keys in a
          stem.
               ]]>
        </body>
    </entry>
    <entry id="execute">
        <body>
            <![CDATA[
execute(arg) - take the argument which is a string and execute it as if it
               were typed in.
               ]]>
        </body>
    </entry>
    <entry id="script_args">
        <body>
            <![CDATA[
  script_args() - prints out the number of arguments to this script
script_args(-1) - returns the script arguments as a list.
 script_args(n) - print the nth argument (first argument is 0).

Note: This is specific to scripts. If the script is called in QDL, the
      arguments may be any QDL data type. If this is called from the command
      line by another process, the arguments will all be strings (even if they
      are passed in as, e.g. numbers). This is why there is a specific argument
      (== -1) to get the result as a stem. If the script is called by QDL, then
      the argument types are preserved.
See also: script_load, script_run
                ]]>
        </body>
    </entry>
    <entry id="script_load">
        <body>
            <![CDATA[
script_load(file_name) - load the script and run it.
script_load(file_name, arg0, arg1, ...) - load the script, passing in the given
                         arguments
Note: Loading a script means to run it in the current session.
See Also: script_run, script_args
]]>
        </body>
    </entry>
    <entry id="script_run">
        <body>
            <![CDATA[
script_run(file_name) - run the script
script_run(file_name, arg0, arg1,...) - run the script, passing in the given
                        arguments
Note: Running a script means that a new clean environment is created and the
      script is run there. Output and input, however, are done in the current
      console.
See Also: script_load, script_run, scan, say, print
]]>
        </body>
    </entry>

    <entry id="info">
        <body>
            <![CDATA[
info() -- a stem of all current information about the session
          such as load paths, memory and such.
info(key) - key is a string. This returns the single value for the given key.
E.g. info('user.home_dir') prints out the current user's home directory.
See also: constants()
]]>
        </body>
    </entry>
    <entry id="constants">
        <body>
            <![CDATA[
constants() - all constants associated with the system
constants(key) - key is a string. This returns the value of a specific key.
E.g.
     constants('file_type.binary')
returns the integer that can be used in the file_read function.
See also: info()
                ]]>
        </body>
    </entry>
    <entry id="is_defined">
        <body>
            <![CDATA[
is_defined(var) - a boolean-valued function that tells you if a given variable
                  has been named.
Note: the argument is not a string, it is the actual variable.
                ]]>
        </body>
    </entry>
    <entry id="is_function">
        <body>
            <![CDATA[
is_function(name) - checks if the value of name (it is a string) is defined.
is_function(name, arg_count) checks if a function given in name with the number
                    of arguments is defined.
                ]]>
        </body>
    </entry>
    <entry id="os_env">
        <body>
            <![CDATA[
os_env() - return a stem of all operating system environment values currently
           known by the system
os_env(arg0, arg1, ...) = given a list of names (as strings) return a stem with
                          each name as a key. If a property
                          is not found, that entry is omitted.
E.g: os_env('PATH') will give you the values of the PATH variable on most
     systems
Note 1: If you set environment variables in a shell script that invokes QDL,
        you may recover them using this call.
Note 2: This is always empty in server mode! Scripts have no access to the
        underlying system.
                ]]>
        </body>
    </entry>
    <entry id="remove">
        <body>
            <![CDATA[
remove(var) - remove a variable and its value from the symbol table.
Note: This expunges it from the session and any future attempts to access it
      will result in errors until it is set again.
See also: is_defined
                ]]>
        </body>
    </entry>
    <entry id="script_path">
        <body>
            <![CDATA[
script_path() - returns the list of paths used to resolve scripts
script_path(arg) - sets the script path. Either this is a string each of whose
                   paths are separated with a colon, e.g. 'path0:path1' or it
                   is a stem of paths.
Note: When invoking a script with an absolute path, that is run. If the path
      is relative, then the script paths are used to resolve it. Note that if
      relative path has a scheme for a VFS, then this restricts resolution to
      those paths. If the path is unqualified, every path is checked.
See also: script_load, script_run
]]>
        </body>
    </entry>
    <entry id="module_path">
        <body>
            <![CDATA[
   module_path() - returns the list of paths used to resolve loading modules
module_path(arg) - sets the module path. Either this is a string each of whose
                   paths are separated with a colon, e.g. 'path0:path1' or it
                   is a stem of paths.
Note: When loading a module with an absolute path, that is run. If the path is
      relative, then the module paths are used to resolve it. Note that if
      relative path has a scheme for a VFS, then this restricts resolution to
      those paths. If the path is unqualified, every path is checked.
See also: module_load
]]>
        </body>
    </entry>
    <entry id="to_number">
        <body>
            <![CDATA[
to_number(arg) - convert a string or stem of strings to numbers. Each number
                 must be a valid string representation.
                ]]>
        </body>
    </entry>
    <entry id="to_string">
        <body>
            <![CDATA[
to_string(arg) - arg is anything and the result is a string representation
                 of it.
to_string(arg, is_pretty_print) - attempt to put the result in to a nicer
                 format.
Note: The print or say function effectively calls this and spits out the
      result to the console.
]]>
        </body>
    </entry>
    <entry id="to_boolean">
        <body>
            <![CDATA[
to_boolean(arg) - arg is anything and the result is a boolean representation.
                  Note that this means
                  strings - true is only returned if the value is 'true'
                  integers - true is only returned if the value is 1
                  decimals - true is only returned if the integer part is 1
                  booleans - returned unchanged.
                  stems - applied to each element.
]]>
        </body>
    </entry>
    <entry id="var_type">
        <body>
            <![CDATA[
var_type(arg0, arg1,...) - returns a list of integers that show the type of
                           each argument.
               ]]>
        </body>
    </entry>
    <entry id="break">
        <body>
            <![CDATA[
break() - immediately terminates a loop.
See also: continue, return
               ]]>
        </body>
    </entry>
    <entry id="check_after">
        <body>
            <![CDATA[
check_after(conditional) - in loops, this means that the conditional is checked
                           at the end of an interation rather than before the
                           iteration. This effectively gives a post-positional
                           loop.
                ]]>
        </body>
    </entry>
    <entry id="common_keys">
        <body>
            <![CDATA[
common_keys(stem1., stem2.) - returns a list of keys common to both stems.
               ]]>
        </body>
    </entry>
    <entry id="contains">
        <body>
            <![CDATA[
contains(source, snippets) - returns a conformable result for any combination
                             of stems and strings. If both arguments are
                             string, the result is a boolean. If source is a
                             stem and snippets is a string, then the result is
                             a boolean stem with a true for each entry that
                             contains the snippet etc.
contains(source, snippets, case_sensitive) -- if case_sensitive is true, which
                             is the default, all testing is done preserving
                             case. If false, all arguments are converted to
                             lower case first.
Note: Original arguments are never altered.
]]>
        </body>
    </entry>
    <entry id="continue">
        <body>
            <![CDATA[
continue() - jumps to the next iteration in a loop
See also: break, return
                ]]>
        </body>
    </entry>
    <entry id="for_keys">
        <body>
            <![CDATA[
for_keys(var, stem.)

  var - is a simple variable and will contain the current key during the loop.
        If it has already been defined, its values will be over-written.
stem. - is a stem variable. The keys of this stem will be assigned to the var
        and may be accessed  in the loop.
Note: This only operates inside of looping constructs.
See also: for_next, to loop over values of the stem
                ]]>
        </body>
    </entry>
    <entry id="for_next">
        <body>
            <![CDATA[
There are two versions. The first allows you to simply define the looping
parameters with integers, the second lets you use any list and iterate
over the values
Meth0d #1:
----------
for_next(var, stop_value [,start_value, increment])
        var - the variable to be used. As the loop is executed, this value will
              change.
 stop_value - the final value for the loop. When the variable acquires this value,
              the loop is terminated (so the loop body does not execute with
              this value!)
start_value - (optional, default is 0). The first value assigned to var.
  increment - (optional, default is 1). How much the loop variable should be
              incremented on each iteration.

Method #2:
----------
for_next(var, arg.)
        var - the variable to be used. As the loop is executed, this value will
              change.
        arg. - any stem. The keys are iterated over and the values are
               assigned to var.

Note: This only functions in looping constructs.
See also: for_keys to loop over the keys in a stem.
                ]]>
        </body>
    </entry>
    <entry id="index_of">
        <body>
            <![CDATA[
index_of(source, snippets) - returns a conformable stem of integers giving the
                  location of the snippet or a -1 if the snippet is not found.
index_of(source, snippets, case_sensitive) - if true (default) all comparisons
                  are case sensitive. If false, all are converted to lower
                  case first.
                ]]>
        </body>
    </entry>
    <entry id="module_import">
        <body>
            <![CDATA[
module_import(urn)- import the given module using its default alias.
module_import(urn, alias) - import the module, assigning it a different alias.
module_import(arg.) - import a bunch of modules in a stem
Note: A module must be loaded before it can be imported or the system does not
      know about it.

E.g.
  module_import(urn0, [urn1, 'curves'], [urn2. 'complex'])

This will import 3 modules with urn0, urn1 and urn2. urn0 is importe
with the default alias, urn1 and urn2 are imported with the specified
aliases.
Returns:
  - null if nothing imported
  - a list of aliases that were imported that corresponds to the input arg.
]]>
        </body>
    </entry>
    <entry id="module_load">
        <body>
            <![CDATA[
module_load(path) - load the module into the current session from the given
                    file. It cannot be used until it is imported.
module_load(path, type) - load the module. If type is 'file' (default) then
                    this is assumed to be QDL and loaded. If the type is 'java'
                    then the path is actually the fully qualified class name
                    and this is loaded from the Java virtual machine.
module_load([[path0{,type0}],path1{,type1}], . . . [pathn{,typen}]])
          load all of the given modules. The typek are optional.
Modules defined outside of the running QDL session must be loaded before being
imported, since you may import multiple instances of the module with
different aliases.

Returns:
  - null if nothing loaded
  - fully qualified name  of the loaded module
  - stem of fully qualified names (if there are multiple modules in the file).

E.g. load and import a module
   module_import(module_load('complex'))
complex

This looks for the module named complex then complex.mdl in the module
path and loads it. It then imports an instance using the default alias
the result is the name of the module in the session.

See also:module_import
             ]]>
        </body>
    </entry>
    <entry id="raise_error">
        <body>
            <![CDATA[
raise_error(message) - raises an error and propagates the message in to the
                       catch block
raise_error(message, code) - add and option numeric code
Note: This ONLY works inside a try[ ... ]catch[] block

Inside the catch block the message and code arguments are accsesible as
error_message
error_code

The error_code of -1 is reserved by the system, so if there is system error
you can catch that:

   try[3/0;]catch[if[error_code==-1]then[say(error_message);];];
divide by zero

Here is an example of how to handle mutliple conditions. we are simply
echoing the error_message, but yo can have any processing at that point
you need/want

j := 41;
try[
     remainder := mod(j, 3);
     if[remainder == 0][say('A remainder of 0 is fine.');];
     if[remainder == 1][raise_error(j + ' not divisible by 3, R==1', 1);];
     if[remainder == 2][raise_error(j + ' not divisible by 3, R==2', 2);];
 ]catch[
    if[error_code == 1][say(error_message);];
    if[error_code == 2][say(error_message);];
 ]; // end catch block
41 not divisible by 3, R==2


See also:try, catch
                ]]>
        </body>
    </entry>
    <entry id="return">
        <body>
            <![CDATA[
return() - return from a function with no value.
return(value)  - return value from this function as the result
Note: This only works for functions.
See also: continue, break
               ]]>
        </body>
    </entry>
    <entry id="replace">
        <body>
            <![CDATA[
replace(source, old, new) - replaces all occurences of old with new in the
                            source. These may be various combinations of stems
                            and strings.

replace(source, regex, new, is_regex) - when is_regex == true,
                            replaces all matching occurences with
                            the regex with new in the source. These may be
                            various combinations of stems and strings.
If is_regex is false, then no regular expressions are used and matching is
as simple strings.

E.g
   replace('abcde', 'cd', '23');
ab23e

E.g. with a regex - replace all blanks with a single period.
  replace('a b c  d e fgh', '\\s+', '.', true)
a.b.c.d.e.fgh

See also: =~, tokenize
                ]]>
        </body>
    </entry>
    <entry id="substring">
        <body>
            <![CDATA[
substring(arg, n) - take a substring of the arg starting at the given index, n,
                    and going to the rest of the string. This will also be
                    done on each element if arg is a stem.
substring(arg, n,length) - start the substring at index n and continue for
                    length characters. If no n + length > size(arg) and
                    no padding, just return the rest of the string
substring(arg, n ,length ,padding) - start at the index, retrieve length
                    characters and if there are not enough, cyclically pad the
                    result with the string padding.
E.g.
   substring('abcdefg',3)
defg
   substring('abcdefg',3,2)
de
   substring('abcdefg',3,10); // asking for more characters than available
defg
  substring('abcdefg',3,11,'pqr'); // padding with string cyclically
defgpqrpqrp
  substring(['abc','pqr'],1,5,'tuv'); // works on lists and stems
[bctuv,qrtuv]
                ]]>
        </body>
    </entry>
    <entry id="to_lower">
        <body>
            <![CDATA[
to_lower(arg) - convert a string or stem of strings to lower case. No effect
                on non-strings.
See also: to_upper
                ]]>

        </body>
    </entry>
    <entry id="to_upper">
        <body>
            <![CDATA[
to_upper(arg) - convert a string or stem of strings to upper case. No effect
                on non-strings.
See also: to_upper
               ]]>
        </body>
    </entry>
    <entry id="tokenize">
        <body>
            <![CDATA[
tokenize(arg, delimiter) - tokenize a string or stem of strings using
                           the given delimeter.
       arg - the string to tokenize
       delimiter - either the delimiter or if the last argument is true,

tokenize(target, arg[, use_regex]) - tokenize a string or stem of strings
                           using the given regex
    target - the string to tokenize
       arg - either the delimiter (use_regex == false) or a regular expression
             (use_regex == true)
     use_regex - flag to use regex.
E.g.
   tokenize('abd:def:123', ':');
[abd,def,123]

E.g.
   Tokenize a string with various delimters using a regular expression

   a := 'a d, m, i.n';
   r := '\\s+|,\\s*|\\.\\s*';
   tokenize(a,r,true);
[a,d,m,i,n]
                ]]>
        </body>
    </entry>

    <entry id="detokenize">
        <body>
            <![CDATA[
detokenize(arg, delimiter) - converts  a string or stem of strings (tokens)
                             into a string using the delimiter between entries.
detokenize(arg, delimiter, options) - options is an integer which is the sum of
          1 for prepend
          2 for omit dangling delimiter
So options = 0 means append, have a trailing delimiter
   options = 1 means prepend, "   "     leading "
   options = 2 means append, omit trailing delimiter
   options = 3 means prepend, omit first delimiter
E.g.
   detokenize([;4],'|')
0|1|2|3|

Note the trailing | added at the end.
E.g.
   detokenize([;4]], '|',2)
0|1|2|3

omits the trailing |.
See also: truncate, constants (which contains the option values for reference)

                ]]>
        </body>
    </entry>
    <entry id="trim">
        <body>
            <![CDATA[
 trim(arg) - remove all leading and trailing blanks from the arg. The argument
             may also be a stem of strings.
]]>
        </body>
    </entry>


    <entry id="vencode">
        <body>
            <![CDATA[
vencode(arg) -  encode a string or stem of them.
Note: This is supremely useful for non-western character sets that must be
      preserved.
E.g.
   vencode('你浣')
$E4$BD$A0$E6$B5$A3
See also: vdecode
]]>

        </body>
    </entry>
    <entry id="vdecode">
        <body>
            <![CDATA[
vdecode(arg) -  decode an encoded string or stem.
See also: vencode
]]>
        </body>
    </entry>

    <!--
         Variable entries
    -->
    <entry id="pp">
            <body>
                <![CDATA[
(workspace variable)
pp - short form for pretty_print.
See pretty_print
                ]]>
            </body>
        </entry>

    <entry id="pretty_print">
            <body>
                <![CDATA[
(workspace variable)
pretty_print - toggle printing stems on one line (off | false) or
               vertically (on | true).
pp is the short form for this.
                ]]>
            </body>
        </entry>
    <entry id="echo">
            <body>
                <![CDATA[
(workspace variable)
echo - toggle echo mode in the workspace. If (on | true), this allows you to
       enter QDL commands without the final semi-colon (;) and the result is
       printed to the console. The default is on.
                ]]>
            </body>
        </entry>

    <entry id="ws_id">
            <body>
                <![CDATA[
(workspace variable)
ws_id - the internal identifier for this workspace. This is especially useful
        if the file name is munged or strange.
See also: name, description
                ]]>
            </body>
        </entry>
    <entry id="description">
            <body>
                <![CDATA[
(workspace variable)
description - A human readable description of this workspace. This is printed
              on load if present. It should tell the user what the workspace
              does for instance. Note that you can set it using a QDL variable
              too so
E.g.
    )ws set description >my_descr.

Would set the contents of this to the list of strings given. Note that this
will be turned into a single string with linefeeds after each entry.
                ]]>
            </body>
        </entry>
    <entry id="debug">
            <body>
                <![CDATA[
Either a workspace variable or the system command to manage debugging
System command:
debug([level , message])
     no args = print out current debug level
       level = an integer in the range 0 (no output) to 5 (trace mode)
               that determines the level of debugging output
     message = A string that contains the entry to the debug log.
See also: log_entry

Workspace variable:
debug - Toggle low-level debugging of the innards of the workspace and QDL.
        This is only useful if you are having a serious issue (such as
        writing a Java module and need to see stack traces). This may be
        (on | true) or (off | false). Generally you do not need this.
                ]]>
            </body>
        </entry>

    <entry id="start_ts">
            <body>
                <![CDATA[
(workspace variable)
start_ts - The time stamp when this was first created. You *may* change this,
           but probably just want the system to manage. Set it using either
           as an integer (in milliseconds) or as an ISO 8601 date.
                ]]>
            </body>
        </entry>
    <entry id="root_dir">
            <body>
                <![CDATA[
(workspace variable)
root_dir - The root directory for all relative file directories. If you attempt
           to save the workspace and the file name is relative (so does not
           e.g., start with a /) then it is assumed to reside in this
           directory. At startup, this is set to the directory where QDL
           was started by default.
E.g.

)save ws/var/my_ws.zml

            would resolve this to root_dir/ws/var/my_ws.zml when saving it.
                ]]>
            </body>
        </entry>

    <entry id="save_dir">
            <body>
                <![CDATA[
(workspace variable)
save_dir - The default directory for saving and loading files. This is set
           at startup automatically This overrides relativizing the path
           from the root_dir.
                ]]>
            </body>
        </entry>

    <entry id="autosave_on">
            <body>
                <![CDATA[
(workspace variable)
autosave_on - Turn on automatically saving workspace. If on then every time the
              autosave_interval (measured in milliseconds) passes, the current
              workspace is saved.
See also: autosave_messages_on, autosave_interval
]]>
            </body>
        </entry>

    <entry id="autosave_messages_on">
            <body>
                <![CDATA[
(workspace variable)
autosave_messages_on - Turn on notifications by the autosave system. If on then
             every time the workspace is automatically saved, the usual
             messages (size, time) are printed. If false, nothing is printed.
See also: autosave_on, autosave_interval
]]>
            </body>
        </entry>

    <entry id="autosave_interval">
            <body>
                <![CDATA[
(workspace variable)
autosave_interval - The interval in either seconds or milliseconds that
                    determines how often the workspace is saved. The default
                    is 10 minutes or 600000 ms. You may enter this as
                    milliseconds (default units) or as seconds.
E.g.
   )ws set autosave_interval 900 sec.

             Would set the autosave interval to 900 seconds or 15 minutes.
             See also: autosave_on, autosave_interval
]]>
            </body>
        </entry>

    <entry id="compress_xml">
            <body>
                <![CDATA[
(workspace variable)
compress_xml - toggle compression of XML on WS save. Options are (on | true)
               or (off | false). Note that on loading workspaces, this not used
                -- the workspace will figure out if it was saved with
                compression and decompress it, so you don't have to worry about
               the compression of stored workspaces.
                ]]>
            </body>
        </entry>
    <entry id="enable_library_support">
            <body>
                <![CDATA[
(workspace variable)
enable_library_support - enable on the fly resolution of scripts as if they
               were functions. You must set the lib_path as well for
               this to work.
See also: lib_path
]]>
            </body>
        </entry>
    <entry id="lib_path">
            <body>
                <![CDATA[
(workspace variable)
lib_path - the paths that are used in resolving library references. A library
           is a collection of QDL scripts, each ending with .qdl. If library
           support is enabled then calls to scripts are resolved dynamically.
           See the reference manual for full details.
E.g.
   if you have a lib_path set and there is a file called sqrt.qdl that accepts
    a single number and returns it square root, then you could invoke it for
    the value of x with
       sqrt(x)
   You could do this directly as
       script_run('/path/to/sqrt.qdl', x)
See also: enable_library_support
                ]]>
            </body>
        </entry>
    <entry id="ws_file">
            <body>
                <![CDATA[
(workspace variable)
ws_file - the current file to save to/load from by default. If you save or load a file
          this is set to that value. You may then issue commands like

)save

          (so no file argument) and the workspace is saved. Note that this is independent of the
          save_dir, which used for resolving all relative path loads and saves.
                ]]>
            </body>
        </entry>
    <entry id="reduce">
            <body>
                <![CDATA[
reduce(@f(), list.) - Takes a dyadic function f and applied it between
             successive members of the list. The final result is a scalar.
E.g.
Are all elements of a boolean list true?
   a. := -1 < n(5); // list of boolean true values
   reduce(@&&, a.)
true
This applies && between each element.
See also: expand()
                ]]>
            </body>
        </entry>
    <entry id="expand">
            <body>
                <![CDATA[
expand(@f, list.) = apply the dyadic function f() pairwise and return the
              intermediate results.
E.g. To compute the factorial of a number and see the parts:
   expand(@*, 1+n(5))
[1, 2, 6, 24, 120]

In this case [1, 2, 3, 4, 5] becomes [1, 1*2, 1*2*3, 1*2*3*4, 1*2*3*4*5]
Note that reduce() effectively returns just the final number. Using expand
lets you use the intermediate results too.
See also: reduce()
                ]]>
            </body>
        </entry>
    <entry id="sin">
             <body>
                 <![CDATA[
sin(x) - the sine of x
x can be any number.
See also: asin()
]]>
             </body>
         </entry>
    <entry id="asin">
             <body>
                 <![CDATA[
asin(x) - the arc sine of x. The result in in radians.
-1 <= x <= 1.
See also: sin()
]]>
             </body>
         </entry>
    <entry id="sinh">
             <body>
                 <![CDATA[
sinh(x) - the hyperbolic sine of x
x can be any number.
See also: asinh()
]]>
             </body>
         </entry>
    <entry id="asinh">
             <body>
                 <![CDATA[
asin(x) - the inverse of sinh of x.
x can be any number
See also: sinh()
]]>
             </body>
         </entry>

    <entry id="cos">
             <body>
                 <![CDATA[
cos(x) - the cosine of x
x can be any number.
See also: acos()
]]>
             </body>
         </entry>
    <entry id="acos">
             <body>
                 <![CDATA[
acos(x) - the arc cosine of x. The result in in radians.
-1 <= x <= 1.
See also: cos()
]]>
             </body>
         </entry>
    <entry id="cosh">
             <body>
                 <![CDATA[
cosh(x) - the hyperbolic cosine of x
x can be any number.
See also: acosh()
]]>
             </body>
         </entry>
    <entry id="acosh">
             <body>
                 <![CDATA[
acosh(x) - the inverse of cosh of x.
1 <= x
See also: cosh()
]]>
             </body>
         </entry>

    <entry id="tan">
             <body>
                 <![CDATA[
tan(x) - the tangent of x
x can be any number.
See also: atan()
]]>
             </body>
         </entry>
    <entry id="atan">
             <body>
                 <![CDATA[
atan(x) - the arc tangent of x. The result in in radians.
x can be any number.
See also: tan()
]]>
             </body>
         </entry>
    <entry id="tanh">
             <body>
                 <![CDATA[
tanh(x) - the hyperbolic tangent of x
x can be any number
See also: atanh()
]]>
             </body>
         </entry>
    <entry id="atanh">
             <body>
                 <![CDATA[
atanh(x) - the inverse of tanh of x.
-1 < x < 1
See also: tanh()
]]>
             </body>
         </entry>

    <entry id="pi">
            <body>
                <![CDATA[
The value of the constant pi in the current precision.
]]>
            </body>
        </entry>
    <entry id="exp">
            <body>
                <![CDATA[
exp(x) - the value of e^x, e is the base of the natural logarithm.
x can be any number.
See also: ln(), log()
]]>
            </body>
        </entry>
    <entry id="ln">
            <body>
                <![CDATA[
ln(x) - the natural logarithm of x
0 < x
See also: exp(), log()
]]>
            </body>
        </entry>

    <entry id="log">
            <body>
                <![CDATA[
log(x) - the base 10 logarithm of x
0 < x
Note that QDL support arbitrary exponentiation, so unlike ln(x), there is no
explicit inverse. The inverse is 10^x.
If you need a different base, divide by the log of the base,
E.g.
  To get log base 2 of 8:
  log(8)/log(2)
3.00000000001
See also: ln(), exp()
                ]]>
            </body>
        </entry>

    <entry id="log_entry">
            <body>
                <![CDATA[
log_entry(level, message) - put a message in the current log.
See also: debug (system command)
]]>
            </body>
        </entry>

    <entry id="nroot">
            <body>
                <![CDATA[
nroot(x,n) - compute the n-th root of x.
             n is an integer.
             If n is odd, x may be any number,
             If n is even, 0 <= 0
The general case of exponentiation x^y will fail for fractional roots and
negative numbers. This is because there is no way to check if an exponent
is an n-th root, due to internal computer representation not being exact,
so
    (-5)^(1/3)
will fail (because 1/3 cannot be represented fully in the computer).
nroot(x,n) explicitly checks, so
   nroot(-5,3)
-1.70997594667670
works.
See also: Reference manual on ^
]]>
            </body>
        </entry>
    <entry id="join">
            <body>
                <![CDATA[
join(x., y.[, axis]) - join two stems together along a given axis.
See also: union or the ~ operator. Those are special cases of
join(x., y., 0 ) == x.~y. == join(x., y.)
Omitting axis means use axis 0,
                ]]>
            </body>
        </entry>
    <entry id="reverse">
            <body>
                <![CDATA[
reverse(list.) - reverse the elements of a list
E.g.
  reverse(n(5))
[4,3,2,1,0]
Another example on a list of lists
  p. := [n(3),n(2)]
  p.
[[0,1,2], [0,1]]
  reverse(p.)
[[0,1],[0,1,2]]
]]>
            </body>
        </entry>
    <entry id="dim">
            <body>
                <![CDATA[
dim(list.) - The dimension of a list. This returns a list of the size of each
             zeroth component. In the case of non-ragged lists, this is
             precisely the number of elements per entry.
E.g.
    dim(n(5))
[5]
Because this has a single index and it is 5 elements long.
     dim(n(3,4,5))
[3,4,5]
This is a list of the indices (three) with the counts in them.
Note: This is only a partial result with ragged arrays, since there is no
      good way to get a single canonical size.
]]>
            </body>
        </entry>
    <entry id="rank">
            <body>
                <![CDATA[
rank(list.) - returns the number (a scalar) of independent indices,
              i.e. size(dim(list.))
E.g.
   rank(n(3,4,5))
3
This means there are three separate indices.
]]>
            </body>
        </entry>
    <entry id="query">
            <body>
                <![CDATA[
query(arg., query_string [, return_indices]) -- do a query on a stem using
            JSON Path syntax.
          arg. - the stem to search
  query_string - a valid JSON Path query string as per
     https://tools.ietf.org/id/draft-goessner-dispatch-jsonpath-00.html
return_indices - (optional) return the indices of the result, not the result.
Returns a list.

This allows you to query stems using the standard query language in JSON.
You supply a stem and a query. Note that the query is a string since 
  In section 2 of the above specification is a JSON object. If you import
  this into the workspace as the stem variable my_json., then here are
  a few examples:

E.g. 1: getting a result set
   query(test., '$..book[?(@.isbn)]'); // get books with an isbn number
[
  {
  author:Herman Melville,
  price:8.99,
  isbn:0-553-21311-3,...

  Note well that results are returned as stem lists of paths.

E.g. 2: Getting the indices
  ndx. := query(test., '$..book[?(@.isbn)]', true); // Just get the indices
  ndx.
[[store,book,2],[store,book,3]]

E.g. 3: Using the indices
   my_json.ndx.0
{
  author:Herman Melville,
  price:8.99,
  isbn:0-553-21311-3,...

Hint: Easy way to import the JSON is to cut and paste it to a file at /my/path/my_json.json
       and issue
       my_json. := from_json(file_read('/my/path/my_json.json'));
                ]]>
            </body>
        </entry>
    <entry id="=~">
            <body>
                <![CDATA[
regex =~ expression
Apply the given regex (which is a string) to match the string representation
of the expression.
Result is always a boolean.

E.g.
   '[a-zA-Z]{3}' =~ 'aBc'; // Checks if the argument has 3 letters
true

Note: ≈ (unicode 2248) is also used for this.
See also: tokenize, replace.
                ]]>
            </body>
        </entry>

    <entry id="⟦">
            <body>
                <![CDATA[
Closed slice notation.
Equivalent to: [|
You may use ⟦ (\u27e6) or [| ,  ⟧ (\u27e7) or |].
⟦ start;stop;count ⟧
will create the list with count elements evenly distributed between start and stop,
inclusive.
See also: slice
                ]]>
            </body>
        </entry>
    <entry id="[|">
            <body>
                <![CDATA[
Closed slice operator open bracket.
See ⟦, slice
                ]]>
            </body>
        </entry>
    <entry id="⟧">
            <body>
                <![CDATA[
Unicode \u27e7. Part of a closed slice.
Equivalent to: |]
Please see help for ⟦
See also: slice
                ]]>
            </body>
        </entry>
    <entry id="|]">
            <body>
                <![CDATA[
Closed slice operator close bracket.
See ⟧, slice
                ]]>
            </body>
        </entry>

    <entry id="→">
            <body>
                <![CDATA[
Unicode \u2192 which is a left arrow used in defining lambdas.
Equivalent to: ->
See also: ->
                ]]>
            </body>
        </entry>
    <entry id="¬">
            <body>
                <![CDATA[
Unicode logical not \u00ac.
Equivalent to: !
                ]]>
            </body>
        </entry>
    <entry id="×">
            <body>
                <![CDATA[
Unicode multiplication \u00d7
Equivalent to: *
                ]]>
            </body>
        </entry>
    <entry id="÷">
            <body>
                <![CDATA[
Unicode division \u00f7
Equivalent to: /
                ]]>
            </body>
        </entry>
    <entry id="≔">
            <body>
                <![CDATA[
Unicode assign left \u2254
Equivalent to: :=
                ]]>
            </body>
        </entry>
    <entry id="≕">
            <body>
                <![CDATA[
Unicode assign right \u2255
Equivalent to: =:
                ]]>
            </body>
        </entry>
    <entry id="∧">
            <body>
                <![CDATA[
Unicode logical and \u2227
Equivalent to: &&
                ]]>
            </body>
        </entry>
    <entry id="∨">
            <body>
                <![CDATA[
Unicode logical or \u2228
Equivalent to: ||
                ]]>
            </body>
        </entry>
    <entry id="∅">
            <body>
                <![CDATA[
Unicode null \u2205
Equivalent to: null
                ]]>
            </body>
        </entry>
    <entry id="≤">
            <body>
                <![CDATA[
Unicode less than or equal to \u2264
Equivalent to: <= or =<
                ]]>
            </body>
        </entry>
    <entry id="≥">
            <body>
                <![CDATA[
Unicode greater than or equal to \u2265
Equivalent to: >= or =>
                ]]>
            </body>
        </entry>
    <entry id="≡">
            <body>
                <![CDATA[
Unicode logical equality \u2261
Equivalent to: ==
                ]]>
            </body>
        </entry>
    <entry id="≠">
            <body>
                <![CDATA[
Unicode not equal to \u2260
Equivalent to: !=
                ]]>
            </body>
        </entry>

    <entry id="≈">
            <body>
                <![CDATA[
Unicode equivalent to \u2248
Equivalent to: =~
Used for regular expression matches
See also: =~
                ]]>
            </body>
        </entry>

    <entry id="unicode">
            <body>
                <![CDATA[
Unicode characters may be put in strings if they are escaped.
QDL also supports several directly as operators. Typing them is, however
dependant on your keyboard layout. Generally every unicode character has
an ASCII version (usually a digraph).

Here is a table of supported unicode characters in QDL:

Standard    Unicode   ALT   escape code   What is it
!              ¬       !    \u00ac         logical not
-              ¯       -    \u00af         unary minus
`              ·       .    \u00b7         raised dot
*              ×       *    \u00d7         multiplication
/              ÷       /    \u00f7         division
+              ⁺       +    \u207a         unary plus
->             →       d    \u2192         lambda function
null           ∅       n    \u2205         null
&&             ∧       &    \u2227         logical and
||             ∨       |    \u2228         logical or
=~             ≈       ?    \u2248         regex matches
:=             ≔       :    \u2254         left assignment
=:             ≕       "    \u2255         right assignment
!=             ≠       \    \u2260         not equal to
==             ≡       =    \u2261         logical equality
<=             ≤       <    \u2264         less than or equals
=>             ≥       >    \u2265         greater than or equals
true           ⊤       T    \u22a4         logical true
false          ⊥       F    \u22a5         logical false
assert[][]     ⊨       A    \u22a8         assert
ceiling        ⌈       k    \u2308         ceiling
floor          ⌊       l    \u230a         floor
~|             ≁       ~    \u2241         last axis join
@              ⊗       @    \u2297         function reference
[|             ⟦       {    \u27e6         left closed slice bracket
|]             ⟧       }    \u27e7         right closed slice bracket
transpose      τ       t    \u03c4         alias for the transpose function.
pi             π       p    \u03c0         Greek letter pi.


The ALT keys are only available if you are running QDL in ANSI mode. So
alt+d inserts the definition arrow, for instance. Note that if you
are running ANSI mode, the ALT keys do not work in external editors,
since the mapping is local to QDL (or it might really screw up your system).

You can request help on any QDL symbol by typing
    )help symbol
E.g.
    )help ∅
    
would print the entry for null.
                ]]>
            </body>
        </entry>

    <entry id="assert">
            <body>
                <![CDATA[
assert[boolean][expression]
is a directive that tells the system to fail if the boolean is false. The
result will be an error returned with the expression evaluated (if possible)
and turned into a string.
E.g.
assert[ script_args() == 2 ]['You must supply both a username and password.'];

This stops further processing and essentially allows you to introduce and
unrecoverable error if needed.

Assertions may be globally turned off and on with the assertions_on variable
in the workspace, or as a configuration option. One common use is to have
them on for development and off in production.
]]>
            </body>
        </entry>
    <entry id="for_each">
            <body>
                <![CDATA[
for_each(@f, arg_1., arg_2., ..., arg_n.) - Apply the n-adic function, f, to
           each element of the outer product of the arg_k.
Simple example, making a multiplication table.
   a. := for_each(@*, 1+n(5), 1+n(6))
   a.
[
   [1,2,3,4,5,6],
   [2,4,6,8,10,12],
   [3,6,9,12,15,18],
   [4,8,12,16,20,24],
   [5,10,15,20,25,30]
]

Things to note. The result is the product of the stems, so here there is
a 5 x 6 array that results. a.i.j is the product of the i-th and j-th elements.

Another example. Create the grid points for a quadric (polynomial) surface over
a a region.
   z(x,y) -> x*y;
   z. := for_each(@z, [|-1;1;15|],[0;3;0.25])
   dim(z.)
[15,12]
This creates a table over the region of the plane for -1 <= x <= 1
and 0 <= y < 3. There are 15 total points in the x direction and
the y direction is done in increments of 0.25, resulting in 12 values,
so the result is a 15 x 12 array, with z evaluated at each point.
                ]]>
            </body>
        </entry>
    <entry id="⊨">
            <body>
                <![CDATA[
⊨
unicode 22a8, aka assert is used to mark a conditional that, when false, should stop
program execution immediately. There are two forms,one with a keyword, assert
and the other with the unicode Math symbol for assertion, ⊨. The general forms are
⊨ conditional : message
assert[ conditional ][ message]

If the conditional is false, the message is returned.

E.g.
⊨ script_arg() ≡  2 : 'you must supply both a username and password';

alternately

assert[script_arg() ≡  2 ][ 'you must supply both a username and password'];

                ]]>
            </body>
        </entry>
    <entry id="block">
            <body>
                <![CDATA[
Keyword.
block is a reserved work to denote the beginning of a local environment.
It is set off with []. Anything defined inside the block is local only
to that block.
E.g.
   a := 'foo';
   block[a := 'baz'; ok := true;];
   is_defined(ok);
false
   a
baz

a gets re-assigned to 'baz' inside the block, ok does not exist any place but the block.
This is extremely useful in many places, such as scripts.
                ]]>
            </body>
        </entry>

    <entry id="slice">
            <body>
                <![CDATA[
A slice is an list of numbers. There are two main types
Open slice: [start;stop;step]
which will produce the list
[start, start+step, start +2*step, ... ]
ending when stop < start + n*step.
If start is omitted, it is assumed to be 0 (zero).
If step is omitted, it is assumed to be 1.
E.g. [;5]
[0,1,2,3,4]
E.g. using a slice in a loop
  while[for_next(j, 1+2*[;6])][say(j);]
prints 1, 3, 5, 7, 9, 11
E.g. [2;5;0.7]
[2,2.7,3.4,4.1,4.8]
Note well: in an open slice, you do not necessarily know how
           many elements are in the resulting list. Here there
           are 5.

Closed slice [|start;stop;count|]
This will produce the list from
[start, ... , stop] (inclusive)
and will have exactly count element in it.
If start is omitted, it is assumed to be 0 (zero).
E.g. [|-pi()/4; pi()/3; 11 |]
[-0.785398163397447,-0.602138591938043, ... ,1.047197551196593]

produces a list of 11 equally spaced numbers from -pi/4 to pi/3,
including the endpoints.
]]>
            </body>
        </entry>
    <entry id="differ_at">
            <body>
                <![CDATA[
differ_at(s0, s1) - find first index at which two strings differ. If the
               strings are equal then a value of -1 is returned.
               Read: 's0 and s1 differ at index i'
               If one string is a substring of
               another, then the index is the length (i.e. this is the index in
               the longer string). You may also apply this to stems of strings.

E.g.
   differ_at('abcde', 'ab')
2
   differ_at('abcd','abcd')
-1
   differ_at(['abcd','efghij'],['abq','efgp'])
[2,3]
  differ_at(['abcde','abed'], 'abcq')
[3,2]
]]>
            </body>
        </entry>

    <entry id="version">
            <body>
                <![CDATA[
The current version of QDL is 1.3-QDL-SNAPSHOT
                ]]>
            </body>
        </entry>
    <entry id="if">
                <body>
                    <![CDATA[
Keyword.
Denotes a conditional statement:
Basic conditional
   if[ boolean ][ (statement;)*];
Conditional with an else clause
   if[ boolean ][ (statement;)*]else[ (statement;)*];

See also: then, else, ?
                    ]]>
                </body>
            </entry>
    <entry id="?">
                <body>
                    <![CDATA[
Used in the ternary operator
   boolean ? expression0 : expression1
If boolean is true, then expression 0 is evaluated and returned. Otherwise
expression1 is used.

    user_name := script_args() == 2 ? script_args(1) : 'guest';

These may be used like any other algebraic expression, where the if conditional
cannot be.
See also: if, then, else
                    ]]>
                </body>
            </entry>
    <entry id="then">
                <body>
                    <![CDATA[
Keyword.
Optional connector in conditional statements. It may be ommitted or not.
These are equivalent
   if[2 < 3][say('foo');];
   if[2 < 3]then[say('foo');];
You may have space around the then keyword.
See also: if, else, ?
                    ]]>
                </body>
            </entry>
    <entry id="else">
            <body>
                <![CDATA[
Keyword.
This is used in conditional statements. It is optional in the sense that
not every conditional needs one, but if you do, it must be included, unlike
the then keyword.
   if[2<4][say('then');]else[say('else');];
See also: if, then, ?
                ]]>
            </body>
        </entry>

    <entry id="while">
            <body>
                <![CDATA[
Keyword.
This is used for QDL's looping  construction:
   while[ boolean ][(statement;)*];
or with the optional do keyword
   while[ boolean ]do[(statement;)*];
See also: do, for_next, for_keys, return
                ]]>
            </body>
        </entry>
    <entry id="do">
            <body>
                <![CDATA[
Keyword
Optional connector in while loops.
See also: while
                ]]>
            </body>
        </entry>
    <entry id="module">
            <body>
                <![CDATA[
Keyword.
This is for the QDLs modules which are self-contained units of code:
module[uri, alias
  ][
  >> General comments
  (statement;)*
];
To see the general comments for a module in the workspace type
   )modules uri|alias -help

See also: body, module_load, module_import.
                ]]>
            </body>
        </entry>
    <entry id="body">
            <body>
                <![CDATA[
Keyword.
Optional keyword connecting clauses in define and module statements.
E.g.
   define[f(x)][...
   define[f(x)]body[...
See also: define, ->
                ]]>
            </body>
        </entry>
    <entry id="->">
            <body>
                <![CDATA[
Lambda function definition. A lambda function a user defined function:
   f(x)->cos(x);
would create a new function called f(x) which would evaluate the cosine
and automatically return it.
For multiple expressions, use [ ] and there is no automatic return:
   f(x)->[y:= x/2;return(cos(y));];
See also: define
                ]]>
            </body>
        </entry>
    <entry id="keywords">
            <body>
                <![CDATA[
The reserved keywords in QDL are

true    if     while   try     module   define   block
false   then   do      catch   body
null    else   assert

You may use the help facility for any of these.
                ]]>
            </body>
        </entry>

    <entry id="try">
            <body>
                <![CDATA[
Keyword
try denotes the QDLs exception handling statement.

   try[(statement;)*]catch[(statement;)*];

Note that the catch keyword is not optional. In this case, the statements in
the try[ ... ] block are done and only if there is an error, the statements
in the catch[ ... ] block are done.

   try[1/0;]catch[say('oops!');]
oops!

The raise_error function lets you have much more fine-grained handling of
errors.

See also: raise_error
                ]]>
            </body>
        </entry>
    <entry id="catch">
            <body>
                <![CDATA[
Keyword
Used as part of the try[ ... ] catch[ ... ] statement.
See also: try
                ]]>
            </body>
        </entry>
    <entry id="true">
            <body>
                <![CDATA[
Keyword
Logical true.
See also: false
                ]]>
            </body>
        </entry>
    <entry id="false">
            <body>
                <![CDATA[
Keyword
Logical false
See also: true
                ]]>
            </body>
        </entry>
    <entry id="null">
            <body>
                <![CDATA[
Keyword
The null, (or unicode 2205, ∅) a special value that denotes that
no definite value has been assigned yet.
A common use is to define a variable to null to put it
in the correct scope for subsequent operations:
   a := null;
   if[2 < 3][a :=0;]else[a:=1;]
   a
0
Had a not been set to null first, then it would have only existed inside
the conditional and attempts to access it would result in an error.
See also: is_defined
                ]]>
            </body>
        </entry>
    <entry id="values">
            <body>
                <![CDATA[
values(arg) - return the values of a stem as a flat list

Note that if arg is a scalar, the result is a stem of the value only.

This is a compliment to list_keys(arg.) which returns the keys as a list.
One caveat is that there is no general order and only unique values are
returned. This does only processes a single dimension in a stem,  hence will
not unpack embedded stems.
E.g.
    zeta.'A' := ['p','q'];zeta.'B' := 'r';zeta.'C' := 's'
    values(zeta.)
[[p,q],r,s]
    reduce(@~, values(mask(zeta., {'A':true,'B':false,'C':true})))
[p,q,s]

E.g. values returned are unique.
  arg.foo := 2; arg.bar := 2; arg.baz := 2
  values(arg.)
[2]

See also: list_keys, keys.
                ]]>
            </body>
        </entry>
    <entry id="floor">
            <body>
                <![CDATA[
floor(arg) - compute the mathematical floor of the argument.
             This is the greatest integer less than or equal to it argument

E.g.
   floor(3.4)
3

Compare with the floor operator, ⌊, which behaves identically, but is not a function

    floor(-3.4)
-4
See also: ⌊, ceiling, ⌈
                ]]>
            </body>
        </entry>
    <entry id="⌊">
            <body>
                <![CDATA[
unicode 230a aka the floor operator. This behaves identically to the floor
function, but is an operator:
E.g.
   ⌊-3.4
-4
   ⌊[-2;3;0.7]
[-2,-2,-1,0,0,1,2,2]

See also: floor, ceiling, ⌈
                ]]>
            </body>
        </entry>
    <entry id="ceiling">
            <body>
                <![CDATA[
ceiling(arg) - compute the ceiling of the argument.
               This is the least integer greater than or equal to arg.

E.g.
   ceiling(4.5)
5
   ceiling(-4.5)
-4
See also: floor, ⌊
                ]]>
            </body>
        </entry>
    <entry id="⌈">
            <body>
                <![CDATA[

unicode 2308 aka the ceiling operator. This behaves identically to the ceiling
function, but is an operator.
E.g.
  ⌈[-2;3;0.7]
[-2,-1,0,1,1,2,3,3]

See also: ceiling, floor, ⌊
                ]]>
            </body>
        </entry>
    <entry id="%">
            <body>
                <![CDATA[
Integer division. This is normal division, but the remainder is discarded.
The result is always an integer.
E.g.
  5432%321
16
  3245.4432%1; // % by 1 effective returns the integer part of a decimal
3245
   frac(x)->x - x%1; // returns fractional part of a number
   frac(5432/432)
0.574074074074074
                ]]>
            </body>
        </entry>
    <entry id="define">
            <body>
                <![CDATA[
Keyword.
This denotes a full function definition. Functions definitions are different
from lambdas in that they may contain statements. So for instance, you may
have an if[]then[] in a defined function, but have to use the ternary operator
of boolean?x:y in a lambda definition. Full syntax is

define[
   function_signature
   ][
   >> Comments
   body
 ]

Comments will be displayed in system help under

)help name arg_count


                ]]>
            </body>
        </entry>

    <entry id="~">
            <body>
                <![CDATA[
The join operator. This is both monadic and dyadic operates only on lists.

The reason this only operates on lists is that if two stems share a common
index, then it is unclear at all how to decide which to keep. Lists
can, however, always be extended, since it is clear how to make more
indices.

Dyadic operation.
a. ~ b. will append the second list to the first, extending indices as needed,
E.g.
  [3;7]~[4;11]
[3,4,5,6,4,5,6,7,8,9,10]

E.g. Operation on higher rank lists
  n(4,5)~n(3,4)
[
  [0,1,2,3,4],
  [0,1,2,3,4],
  [0,1,2,3,4],
  [0,1,2,3,4],
  [0,1,2,3],
  [0,1,2,3],
  [0,1,2,3]
 ]

Monadic operation.
~a. is equivalent to []~a. and has the effect of re-ordering the list
from index 0. This is a very common idiom.
E.g.
  r. := [8,14,-7,16,0];
  r1. := mask(r., r. <= 0)
  r1.
{2:-7,4:0}
  ~r1.
 [-7,0]

E.g. Glom two sparse lists together then re-index them
  ~{2:4,3:5}~{1:7,11:-2}
[4,5,7,-2]

See also: ~|, join
                ]]>
            </body>
        </entry>
    <entry id="~|">
                <body>
                    <![CDATA[
Join along last axis. Normal join, ~, operates along the zero-th
axis.
    a. ~| b. == join(a., b., -1)

E.g.
  [;5]~|[10;15]
[
  [0,10],
  [1,11],
  [2,12],
  [3,13],
  [4,14]
 ]

The last axis is the columns, so this in effect pastes two lists
together to make an array.

E.g. Making a table with headings. Make the table with |~ then stick
     the heading at the top, which must conform to the shape of the
     table.

  [['x','y']]~([;5]~|[10;15])
[
  [x,y],
  [0,10],
  [1,11],
  [2,12],
  [3,13],
  [4,14]
 ]

 E.g. A higher rank example. Note that subsetting is in effect, so the
 resulting shape is limited to the smaller (left hand in this case)
 argument. The join is along the last axis still, which is always
 the columns.
   n(3,4,100+n(12)) ~| n(4,5,n(20))
[
  [
    [100,0],
    [101,1],
    [102,2],
    [103,3]
  ],
  [
    [104,5],
    [105,6],
    [106,7],
    [107,8]
  ],
  [
    [108,10],
    [109,11],
    [110,12],
    [111,13]
  ]
 ]

 See also: ~, join
                    ]]>
                </body>
            </entry>
    <entry id="≁">
            <body>
                <![CDATA[
Unicode
This is equivalent to ~|, join operator along last axis.

See: ~|
                ]]>
            </body>
        </entry>
    <entry id="indices">
            <body>
                <![CDATA[
indices(args. ,[axis]) - return all the indices for either the entire stem
            or for the given axis. The axis may be signed, so, e.g.
            axis == -1 is the last axis.
E.g.
    a. := [;5]~n(2,3, n(6))
    a.
[0,1,2,3,4,[0,1,2],[3,4,5]]
    indices(a., 0); // get the first axis
[0,1,2,3,4]
    indices(a., 1); // get the last axis
[[5,0],[5,1],[5,2],[6,0],[6,1],[6,2]]
    a.[6,2]
5

Note that indices(a., 1) == indices(a., -1) in this case.

                ]]>
            </body>
        </entry>
    <entry id="transpose">
            <body>
                <![CDATA[
transpose(x.) - reverses dim(x.) an remaps the axes of x. If x. is a matrix,
           this is the standard matrix transpose
transpose(x., a) - transforms x. so that the zeroth axis is a.,
transpose(x., permutation.) - transforms x. as per the permutation.

This does not alter x.  This can be extremely useful at restructuring
data. This has no effect on a rank 1 stem (i.e. a simple list).


Note that this intended to operate  on stem lists
of higher dimension and on general stems may lose some of the
entries (of lower dimensionality). The stems do not need all
integer indices, just the same dimension.

 E.g. Normally reduce operates on the first axis -- by row.
To sum along the last axis (columns) compare
    reduce(@+, [[1,2,3],[5,6,7]]); // adds the first row to the second
[6,8,10]
    // Now, add the columns, reducing each list.
    reduce(@+, transpose([[1,2,3],[5,6,7]],-1));
[6,18]

An axis of -1 is always the last axis.
Alias: τ (greek letter tau).
This could be an operator in its own right, but is much easier to
work with as a function in most contexts. The alternate Greek letter
is supplied if you want to make it more terse.
                ]]>
            </body>
        </entry>

    <entry id="τ">
            <body>
                <![CDATA[
Alias for the transpose function.
See the entry for transpose for more.
                ]]>
            </body>
        </entry>
    <entry id="greek">
            <body>
                <![CDATA[
QDL supports Greek letters for function and variable names.
These are, of course, strictly a matter of taste.
Table of Greek letters with unicode:

\u0391  Α α  \u03b1
\u0392  Β β  \u03b2
\u0393  Γ γ  \u03b3
\u0394  Δ δ  \u03b4
\u0395  Ε ε  \u03b5
\u0396  Ζ ζ  \u03b6
\u0397  Η η  \u03b7
\u0398  Θ θ  \u03b8
          ϑ  \u03d1
\u0399  Ι ι  \u03b9
\u039a  Κ κ  \u03ba
          ϰ  \u03f0
\u039b  Λ λ  \u03bb
\u039c  Μ μ  \u03bc
\u039s  Ν ν  \u03bd
\u039e  Ξ ξ  \u03be
\u039f  Ο ο  \u03bf
\u03a0  Π π  \u03c0
          ϖ  \u03d6
\u03a1  Ρ ρ  \u03c1
          ϱ  \u03f1
\u03a2  Σ ς  \u03c2
          σ  \u03c3
\u03a3  Τ τ  \u03c4
\u03a4  Υ υ  \u03c5
\u03a5  Φ φ  \u03c6
\u03a6  Χ χ  \u03c7
\u03a7  Ψ ψ  \u03c8
\u03a8  Ω ω  \u03c9

Some of these (such as π()) are reserved and have keyboard
shortcuts in ansi mode. There are variants (e.g. ϑ) allowed
precisely because they are standard technical symbols. The intent
is not to allow you to write in Greek, so none of the characters with
diacritical marks, (e.g. ὰ) are here. Strings in QDL support unicode
so you can certainly write Greek inside them:
E.g.
   say('ἀγεωμέτρητος μηδεὶς εἰσίτω')
ἀγεωμέτρητος μηδεὶς εἰσίτω

("Let no one untrained in geometry enter." -- motto of Plato's Academy)

See also: unicode

                ]]>
            </body>
        </entry>
    <entry id="ansi_mode">
            <body>
                <![CDATA[
(workspace variable)
ansi_mode - (read only) true if QDL is running in ANSI mode.

QDL may be started in ANSI (American Standards National Institute) mode
which allows for command line editing (normally not possible in Java)
and a host of other things. The default terminal for QDL is
the ASCII (American Standard Code for Information Interchange)
terminal, which is very limited but will run everywhere.
ANSI is enabled by specifying the -ansi
switch at the command line. See the details in your distro at

docs\iso6429.pdf

or online at

https://cilogon.github.io/qdl/docs/iso6429.pdf

Note that this does not persist through WS saves. If you are working
in ANSI mode and the system is restarted in ASCII mode, that is
what is available.
                ]]>
            </body>
    </entry>

	        <entry id="insert">
            <body>
   <![CDATA[
insert(source, snippet, index) - insert the snippet into the source string
     at the given index.

E.g.
    insert('abcd', 'foo', 2)
abfoocd

  insert('abcd', '....', differ_at('abc','abq'))
ab....cd
                ]]>
            </body>
        </entry>

    <!--
        entry template
    -->
    <!--
    <entry id="">
            <body>
                <![CDATA[
                ]]>
            </body>
        </entry>
          -->
</help>

